<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue3.0 æºç è§£è¯»</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/slamdunk-the-vue3/onepunch.jpeg">
    <script src="https://hm.baidu.com/hm.js?4484bd6412288feacc311fd7f2054116"></script>
    <meta name="description" content="Vue3.0 æºç è§£è¯»">
    <link rel="preload" href="/slamdunk-the-vue3/assets/css/0.styles.8a77ab8b.css" as="style"><link rel="preload" href="/slamdunk-the-vue3/assets/js/app.5cce7937.js" as="script"><link rel="preload" href="/slamdunk-the-vue3/assets/js/2.53f3bd5a.js" as="script"><link rel="preload" href="/slamdunk-the-vue3/assets/js/12.62ea020d.js" as="script"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/10.3b123913.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/11.a5f7bb07.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/13.ed39d1e0.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/14.f0377083.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/15.ec7a16fa.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/16.1d75929f.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/17.8d4038c4.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/18.ead9747b.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/19.7a6d3a31.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/20.7f0cbf2c.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/21.039e5e49.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/22.1d209a45.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/3.42ea3513.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/4.fca74266.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/5.2f76157e.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/6.0e4c4490.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/7.f11fe9a0.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/8.933cd8dd.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/9.d2c46ed2.js">
    <link rel="stylesheet" href="/slamdunk-the-vue3/assets/css/0.styles.8a77ab8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/slamdunk-the-vue3/" class="home-link router-link-active"><!----> <span class="site-name">Vue3.0 æºç è§£è¯»</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/slamdunk-the-vue3/main/" class="nav-link router-link-active">
  Vue 3.0 è§£è¯»
</a></div><div class="nav-item"><a href="/slamdunk-the-vue3/about.html" class="nav-link">
  å…³äºæˆ‘
</a></div><div class="nav-item"><a href="https://github.com/hkc452/slamdunk-the-vue3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/slamdunk-the-vue3/main/" class="nav-link router-link-active">
  Vue 3.0 è§£è¯»
</a></div><div class="nav-item"><a href="/slamdunk-the-vue3/about.html" class="nav-link">
  å…³äºæˆ‘
</a></div><div class="nav-item"><a href="https://github.com/hkc452/slamdunk-the-vue3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>å“åº”å¼ç³»ç»Ÿ</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/slamdunk-the-vue3/main/vue/reactivity/effect.html" class="sidebar-link">effect</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/reactive.html" class="sidebar-link">reactive</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/baseHandlers.html" class="sidebar-link">baseHandlers</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/collectionHandlers.html" class="sidebar-link">collectionHandlers</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/ref.html" class="sidebar-link">ref</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/computed.html" class="sidebar-link">computed</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>ç¼–è¯‘æ¨¡å—</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/slamdunk-the-vue3/main/vue/compiler/compiler.html" class="sidebar-link">compiler</a></li><li><a href="/slamdunk-the-vue3/main/vue/compiler/parse.html" class="active sidebar-link">parse</a></li><li><a href="/slamdunk-the-vue3/main/vue/compiler/transform.html" class="sidebar-link">transform(å‡†å¤‡å¼€å§‹æ–½å·¥ğŸš§)</a></li><li><a href="/slamdunk-the-vue3/main/vue/compiler/codegen.html" class="sidebar-link">codegen</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>è¿™é‡Œä¸»è¦è®²è®² parse ï¼Œçœ‹çœ‹ Vue æ€ä¹ˆå¯¹æ¨¡æ¿è¿›è¡Œåˆæ­¥çš„è§£æã€‚ åœ¨ compile ä¸­è°ƒç”¨ baseParse è¿›è¡Œ parseï¼Œæ‰€ä»¥è¿™é‡Œå…ˆçœ‹çœ‹ baseParse ã€‚</p> <p>åœ¨è§£æä¹‹å‰ï¼Œä¼šåˆ›å»ºä¸€ä¸ªä¸Šä¸‹æ–‡ï¼Œç”¨äºä¿å­˜å½“å‰è§£æè¿›åº¦å’Œä¸€äº›é…ç½®é¡¹ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>export function baseParse(
  content: string,
  options: ParserOptions = {}
): RootNode {
  const context = createParserContext(content, options)
  const start = getCursor(context)
  return createRoot(
    parseChildren(context, TextModes.DATA, []),
    getSelection(context, start)
  )
}
</code></pre></div><p>options ä¸­åŸºæœ¬æ˜¯ç”¨ parseOptions ä¼ ä¸‹æ¥çš„ options è¿›è¡Œè¦†ç›–ï¼Œ column è¡¨ç¤ºç¬¬å‡ è¡Œï¼Œ line è¡¨ç¤ºç¬¬å‡ åˆ—ï¼Œ offset è¡¨ç¤ºä¼ å…¥ content çš„åå·®ï¼ŒoriginalSource è¡¨ç¤ºåŸå§‹å­—ç¬¦ä¸²ï¼Œåœ¨ parse ä¸ä¼šè¢«ä¿®æ”¹ï¼Œsource ä¸€å¼€å§‹ä»£è¡¨åŸå§‹å­—ç¬¦ä¸²ï¼Œåœ¨ parse è¿‡ç¨‹ä¼šè¢«è£å‰ªï¼Œ inPre è¡¨ç¤ºæ˜¯å¦åœ¨ pre æ ‡ç­¾é‡Œé¢ï¼ŒinVPre è¡¨ç¤ºæ˜¯å¦åœ¨ VPre æ ‡ç­¾é‡Œé¢ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function createParserContext(
  content: string,
  options: ParserOptions
): ParserContext {
  return {
    options: {
      ...defaultParserOptions,
      ...options
    },
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false
  }
}
</code></pre></div><p>å›åˆ° baseParseï¼Œåˆ›å»ºå®Œ context ä¹‹åï¼Œæˆ‘ä»¬é¦–å…ˆè·å–ä¸€å¼€å§‹çš„å­—ç¬¦ä¸²çš„åæ ‡ã€‚ getCursor è¿”å›å½“å‰çš„ è¡Œã€åˆ—ã€åå·®ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function getCursor(context: ParserContext): Position {
  const { column, line, offset } = context
  return { column, line, offset }
}
</code></pre></div><p>ç„¶ååœ¨è°ƒç”¨ createRoot è¿”å›æ ¹èŠ‚ç‚¹çš„ ast ä¹‹å‰ï¼Œä½¿ç”¨ parseChildren å¯¹æ¨¡æ¿è¿›è¡Œè§£æã€‚ä¸€å¼€å§‹çš„ TextModes ä¸ºDATAï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨ compiler é‡Œé¢æ›¾ç»è¯´è¿‡ï¼Œä¸åŒçš„ TextModes ä¼šå½±å“è§£æã€‚ ä»ä¸‹é¢å¯ä»¥çœ‹å‡ºï¼ŒDATA å¯ä»¥åŒ…å« Elementsã€ Entities ï¼Œç»“æŸçš„æ ‡å¿—æ˜¯åœ¨ tags æ ˆä¸­æ‰¾åˆ° å…³é—­ tagï¼Œè€Œå¯¹äº RCDATAï¼Œä¸åŒ…å«  Elementsï¼ŒåŒ…å«Entitiesï¼Œ ç»“æŸçš„æ ‡å¿—æ˜¯ tags æ ˆä¸Šä¸€çº§æœ‰å…³é—­ tagï¼Œ ä¸€èˆ¬å¤„äº textareaï¼ŒRAWTEXT ä¸åŒ…å«  Elements å’ŒEntitiesï¼Œç»“æŸçš„æ ‡å¿—é¡µæ•°æ˜¯ tags æ ˆä¸Šä¸€çº§æœ‰å…³é—­ tagï¼Œä¸€èˆ¬ä½äº style å’Œ script å†…ã€‚å¯èƒ½åœ¨è¿™é‡Œå•ç‹¬è®²æ¦‚å¿µæœ‰ç‚¹æ‡µï¼Œåé¢ç»“åˆè§£æè¿‡ç¨‹æ¥ä¼šåŠ æ·±ç†è§£ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>export const enum TextModes {
  //          | Elements | Entities | End sign              | Inside of
  DATA, //    | âœ”        | âœ”        | End tags of ancestors |
  RCDATA, //  | âœ˜        | âœ”        | End tag of the parent | &lt;textarea&gt;
  RAWTEXT, // | âœ˜        | âœ˜        | End tag of the parent | &lt;style&gt;,&lt;script&gt;
  CDATA,
  ATTRIBUTE_VALUE
}
parseChildren(context, TextModes.DATA, [])
</code></pre></div><p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äº Dom å¹³å°æ¥è¯´ï¼Œå¯¹äº DOMNamespaces.HTML,åŒ…æ‹¬åœ¨ iframe å’Œ noscript æ ‡ç­¾é‡Œé¢ï¼ŒRCDATA è¿˜åŒ…æ‹¬ titleã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>const isRawTextContainer = /*#__PURE__*/ makeMap(
  'style,iframe,script,noscript',
  true
)
getTextMode({ tag, ns }: ElementNode): TextModes {
    if (ns === DOMNamespaces.HTML) {
      if (tag === 'textarea' || tag === 'title') {
        return TextModes.RCDATA
      }
      if (isRawTextContainer(tag)) {
        return TextModes.RAWTEXT
      }
    }
    return TextModes.DATA
}
</code></pre></div><p>ç°åœ¨è¿›è¡Œ parseChildren çš„åˆ†æã€‚é¦–å…ˆè·å–çˆ¶çº§ ä»¥åŠ çˆ¶çº§çš„Namespacesï¼Œnodes æ˜¯è§£æåçš„ AST èŠ‚ç‚¹ã€‚å¯ä»¥çœ‹åˆ°ï¼Œä¸€ä¸ª while å¾ªç¯åˆ¤æ–­æ˜¯å¦è§£æç»“æŸäº†ï¼ŒåŒæ—¶ä¼š ä¼ å…¥å» modeã€ancestorsï¼Œå¯¹äºæ ¹èŠ‚ç‚¹æ¥è¯´ï¼Œancestors ä¸€å¼€å§‹ä¸ºç©ºæ•°ç»„ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseChildren(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[]
): TemplateChildNode[] {
  const parent = last(ancestors)
  const ns = parent ? parent.ns : Namespaces.HTML
  const nodes: TemplateChildNode[] = []

  while (!isEnd(context, mode, ancestors)) {
    ...
  }

  // Whitespace management for more efficient output
  // (same as v2 whitespace: 'condense')
  let removedWhitespace = false
  if (mode !== TextModes.RAWTEXT) {
    ...
  }

  return removedWhitespace ? nodes.filter(Boolean) : nodes
}
</code></pre></div><p>isEnd ç”¨äºåˆ¤æ–­æ˜¯å¦åº”è¯¥è¦ç»“æŸè§£æï¼Œä½†æ˜¯ä¸åŒ TextMode ä¸‹ï¼Œå¯¹ end çš„åˆ¤æ–­æ˜¯ä¸åŒçš„ï¼Œå…¶å®è¿™ç‚¹åœ¨ä¸Šé¢è®² TextModes çš„æ—¶å€™å·²ç»è®²äº†ï¼ŒTextModes.DATA å…è®¸æœ‰æ ‡ç­¾æ²¡é—­åˆï¼Œæ‰€ä»¥åªè¦ç¥–å…ˆæœ‰ç›¸åŒçš„æ ‡ç­¾å°±å¯ä»¥äº†ï¼Œè€Œ RCDATAã€RAWTEXT è¦æ±‚çˆ¶çº§æ ‡ç­¾è·Ÿé—­åˆæ ‡ç­¾ä¸€æ ·æ‰ç®—ç»“æŸï¼Œè€Œå¯¹äº TextModes.CDATA ï¼Œåˆ™è¦æ±‚ <code>]]&gt;</code> ç»“å°¾ï¼Œå¦‚æœéƒ½ä¸ç¬¦åˆè¿™äº›æ¡ä»¶ï¼Œåˆ™çœ‹çœ‹ s æ˜¯å¦ä¸ºç©ºæ¥å†³å®šæ˜¯å¦åˆ°å°½å¤´äº†ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function isEnd(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[]
): boolean {
  const s = context.source

  switch (mode) {
    case TextModes.DATA:
      if (startsWith(s, '&lt;/')) {
        //TODO: probably bad performance
        for (let i = ancestors.length - 1; i &gt;= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true
          }
        }
      }
      break

    case TextModes.RCDATA:
    case TextModes.RAWTEXT: {
      const parent = last(ancestors)
      if (parent &amp;&amp; startsWithEndTagOpen(s, parent.tag)) {
        return true
      }
      break
    }

    case TextModes.CDATA:
      if (startsWith(s, ']]&gt;')) {
        return true
      }
      break
  }

  return !s
}
</code></pre></div><p>å›åˆ° while å¾ªç¯ï¼Œå¦‚æœ isEnd ä¸º falseï¼Œ è¿›å…¥å¾ªç¯ï¼Œå¦‚æœ mode ä¸º <code>mode === TextModes.DATA || mode === TextModes.RCDATA</code> åˆ™è¿›å…¥ if é‡Œé¢ï¼Œå¦è€…å¾€ä¸‹èµ°ï¼Œå¦‚æœè¿™æ—¶ node è¿˜ä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿›è¡Œ parseText æ“ä½œã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>__TEST__ &amp;&amp; assert(context.source.length &gt; 0)
const s = context.source
let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined
if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
    ...
}
if (!node) {
  node = parseText(context, mode)
}
</code></pre></div><p>parseText, çœ‹åå­—å°±çŸ¥é“ç”¨æ¥å¹²å˜›çš„ï¼Œé¦–å…ˆåˆ©ç”¨ endTokens å»åˆ¤æ–­ç»“å°¾ï¼Œåˆ†åˆ«æ˜¯æ ‡ç­¾çš„å¼€å¤´ã€å·¦delimitersï¼Œ å¦‚æœæ˜¯ TextModes.CDATA æ¨¡å¼ä¸‹ï¼Œè¿˜åŒ…æ‹¬ <code>]]&gt;</code>ï¼Œ æˆ‘ä»¬éœ€è¦æœ€å°çš„ endIndexï¼Œå³å°½å¯èƒ½çŸ­çš„ Textï¼Œæ¥ç€ä½¿ç”¨ parseTextData å¯¹å†…å®¹è§£æã€‚</p> <p>parseTextData é¦–å…ˆ slice source å¾—åˆ° rawtextï¼Œç„¶å advanceBy è®© context ä¸­ columinã€ line å¾€å‰è¿›åŒæ—¶å¯¹ context.source è¿›è¡Œåˆ‡å‰²ã€‚æ¥ä¸‹æ¥çš„åˆ¤æ–­ï¼Œå°±æ˜¯å†³å®šè¦ä¸è¦å¯¹ Entities è¿›è¡Œè§£ç ï¼Œå¯¹äº <code>mode === TextModes.RAWTEXT || mode === TextModes.CDATA</code> è¿™ä¸¤ç§ä¸éœ€è¦è§£ç ï¼Œè€Œå¦‚æœæ˜¯å…¶ä»–æ¨¡å¼ï¼Œä½†æ˜¯é‡Œé¢æ²¡æœ‰ <code>&amp;</code>ï¼Œ ä¹Ÿä¸éœ€è¦è§£ç ï¼Œå¦åˆ™è°ƒç”¨ä¼ è¿›æ¥çš„è§£ç å‡½æ•°è¿›è¡Œè§£ç ã€‚</p> <p>parseTextData ç»“æŸåï¼Œè¿”å› AST èŠ‚ç‚¹ï¼Œå…¶ä¸­ç±»å‹ä¸º NodeTypes.TEXTï¼Œ å†…å®¹ä¸º parseTextData è¿”å›çš„å†…å®¹ï¼Œloc ä»£è¡¨è¿™ä¸ªèŠ‚ç‚¹å¼€å§‹ä½ç½®ã€ç»“æŸä½ç½®ä»¥åŠåŸå§‹å†…å®¹ï¼Œå…¶ä¸­ä½ç½®ç”¨ä¸‰ä¸ªç»´åº¦å»è¡¨ç¤º è¡Œã€åˆ—ã€åç§»ï¼Œéœ€è¦è®°ä½çš„æ˜¯ï¼Œç»“æŸä½ç½®æ˜¯å¼€åŒºé—´ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseText(context: ParserContext, mode: TextModes): TextNode {
  __TEST__ &amp;&amp; assert(context.source.length &gt; 0)

  const endTokens = ['&lt;', context.options.delimiters[0]]
  if (mode === TextModes.CDATA) {
    endTokens.push(']]&gt;')
  }

  let endIndex = context.source.length
  for (let i = 0; i &lt; endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1)
    if (index !== -1 &amp;&amp; endIndex &gt; index) {
      endIndex = index
    }
  }

  __TEST__ &amp;&amp; assert(endIndex &gt; 0)

  const start = getCursor(context)
  const content = parseTextData(context, endIndex, mode)

  return {
    type: NodeTypes.TEXT,
    content,
    loc: getSelection(context, start)
  }
}
function parseTextData(
  context: ParserContext,
  length: number,
  mode: TextModes
): string {
  const rawText = context.source.slice(0, length)
  advanceBy(context, length)
  if (
    mode === TextModes.RAWTEXT ||
    mode === TextModes.CDATA ||
    rawText.indexOf('&amp;') === -1
  ) {
    return rawText
  } else {
    // DATA or RCDATA containing &quot;&amp;&quot;&quot;. Entity decoding required.
    return context.options.decodeEntities(
      rawText,
      mode === TextModes.ATTRIBUTE_VALUE
    )
  }
}
</code></pre></div><p>å›åˆ°ä¸Šé¢çš„åˆ¤æ–­ï¼Œå¯¹äº <code>mode === TextModes.DATA || mode === TextModes.RCDATA</code> æ¨¡å¼ä¸‹ï¼Œè®°ä½æ ¹èŠ‚ç‚¹æ˜¯ TextModes.DATA æ¨¡å¼ï¼Œç»§ç»­åˆ¤æ–­ï¼Œå¦‚æœä¸åœ¨ inVPre ä¸‹é¢ï¼Œåˆæ˜¯å·¦ delimiters å¼€å¤´çš„ï¼Œå¯¹äºé»˜è®¤ delimiters å¯¹æ˜¯ <code>{{</code> å’Œ <code>}}</code>ï¼Œè¿™äº›éƒ½æ»¡è¶³ï¼Œåˆ™è¿›è¡Œæ’å€¼ parseInterpolation çš„è§£æã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
    if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) {
        // '{{'
        node = parseInterpolation(context, mode)
      } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') {
       
    }
}
</code></pre></div><p>parseInterpolation æ’å€¼å‡½æ•°å¦‚ä¸‹ï¼Œæ‹¿åˆ°ç•Œå®šç¬¦ï¼Œåˆ¤æ–­æœ‰æ²¡æœ‰ç»“æŸç•Œå®šç¬¦ï¼Œæ²¡æœ‰çš„è¯ï¼ŒæŠ›å‡ºé”™è¯¯ï¼Œè¿”å› undefined ï¼Œè¿™æ ·åç»­å¯ä»¥è¢«ä¸Šé¢è§£è¯»çš„ parseText è¿›è¡Œå¤„ç†ã€‚start æ˜¯æ’å€¼ç¬¦çš„å¼€å§‹ä½ç½®ï¼Œ innerStart æ˜¯ æ’å€¼å†…å®¹å¼€å§‹çš„ä½ç½®ï¼Œè¿™ä¸ªä¼šè¢«è¿›è¡ŒäºŒæ¬¡ä¿®å¤ï¼Œå› ä¸ºå†…å®¹å‰é¢å¯èƒ½ä¼šæœ‰ç©ºæ ¼ï¼ŒåŒæ · innerEnd æ˜¯æŒ‡æ’å€¼å†…å®¹ç»“æŸçš„ä½ç½®ï¼Œä¹Ÿä¼šè¢«äºŒæ¬¡ä¿®å¤ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆ <code>const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)</code> è¿™æ ·ç®—å‘¢ï¼Ÿ</p> <p>é¦–å…ˆ rawContentLength æ˜¯åŸå§‹æ’å€¼çš„é•¿åº¦ï¼Œé‡Œé¢å¯èƒ½åŒ…å«å‰åç©ºæ ¼ä»¥åŠå†…å®¹å¯èƒ½éœ€è¦è§£ç ï¼Œå¦‚æœéœ€è¦è§£ç ï¼Œè§£ç åçš„å†…å®¹æ˜¯æ¯”æ²¡æœ‰è§£ç å‰çš„å†…å®¹é•¿åº¦è¦çŸ­çš„ï¼Œ<code>(preTrimContent.length - content.length - startOffset)</code> æ‹¿åˆ°çš„æ˜¯å†…å®¹åé¢ç©ºæ ¼çš„é•¿åº¦ï¼Œæ‰€ä»¥ endOffset å°±æ˜¯åŸå§‹æ’å€¼å‡å»åé¢ç©ºæ ¼çš„é•¿åº¦ï¼Œä¿®å¤ innerEnd ä¹‹åï¼Œç»§ç»­æŠŠ context æ¨å‘å‰ close çš„é•¿åº¦ï¼Œæœ€åè¿”å›èŠ‚ç‚¹ç±»å‹ä¸º NodeTypes.INTERPOLATIONï¼Œcontent ä¸º NodeTypes.SIMPLE_EXPRESSION ç±»å‹ï¼Œå…¶ä¸­ isConstant ä¼šåœ¨ transformExpression çœŸæ­£ç¡®å®šä¸‹æ¥ï¼Œè¿™é‡Œé»˜è®¤ä¸º falseã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseInterpolation(
  context: ParserContext,
  mode: TextModes
): InterpolationNode | undefined {
  const [open, close] = context.options.delimiters
  __TEST__ &amp;&amp; assert(startsWith(context.source, open))

  const closeIndex = context.source.indexOf(close, open.length)
  if (closeIndex === -1) {
    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)
    return undefined
  }

  const start = getCursor(context)
  advanceBy(context, open.length)
  const innerStart = getCursor(context)
  const innerEnd = getCursor(context)
  const rawContentLength = closeIndex - open.length
  const rawContent = context.source.slice(0, rawContentLength)
  const preTrimContent = parseTextData(context, rawContentLength, mode)
  const content = preTrimContent.trim()
  const startOffset = preTrimContent.indexOf(content)
  if (startOffset &gt; 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset)
  }
  const  =
    rawContentLength - (preTrimContent.length - content.length - startOffset)
  advancePositionWithMutation(innerEnd, rawContent, endOffset)
  advanceBy(context, close.length)

  return {
    type: NodeTypes.INTERPOLATION,
    content: {
      type: NodeTypes.SIMPLE_EXPRESSION,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      isConstant: false,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  }
}
</code></pre></div><p>å›åˆ°å¾ªç¯ï¼Œå¦‚æœä¸æ˜¯æ’å€¼ï¼Œçœ‹çœ‹æ˜¯ä¸æ˜¯å¤„äº TextModes.DATA æ¨¡å¼ï¼Œä»¥åŠç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯ '&lt;'ï¼Œéœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œåªè¦æ²¡æœ‰è‡ªå®šä¹‰çš„ onError ä¸æ˜¯æŠ›å‡ºé”™è¯¯çš„è¯ï¼Œæœ€åçš„éƒ½ä¼šè¢« parseText å…œåº•å¤„ç†çš„ã€‚</p> <p>ä¸‹é¢ç»§ç»­çœ‹ï¼Œå¦‚æœ  <code>s.length === 1</code> åˆ™ ä¸ŠæŠ¥é”™è¯¯ï¼Œå¦åˆ™å¦‚æœçœ‹çœ‹å­—ç¬¦ä¸²ç¬¬äºŒä½æ˜¯ä¸æ˜¯ <code>!</code>ï¼Œå› ä¸ºæœ‰å¯èƒ½æ˜¯ html æ³¨è§£<code>&lt;!--</code>ï¼Œ ä¹Ÿæœ‰å¯èƒ½æ˜¯ DOCTYPE <code>&lt;!DOCTYPE</code>,  å¦‚æœæ˜¯ <code>&lt;![CDATA[</code> å¼€å¤´ä¸” ä¸æ˜¯å‡ºäº Namespaces.HTML å‘½åç©ºé—´ä¸‹çš„è¯ï¼Œåˆ™ç”¨ parseCDATA è§£æï¼Œå¦åˆ™ä¸ŠæŠ¥ <code>CDATA_IN_HTML_CONTENT</code> é”™è¯¯ï¼Œå¦‚æœ <code>!</code> éƒ½æ²¡æœ‰è¢«å¤„ç†çš„è¯ï¼Œä¸ŠæŠ¥ <code>INCORRECTLY_OPENED_COMMENT</code> é”™è¯¯ï¼Œä¸Šé¢ä¸¤ä¸ªé”™è¯¯éƒ½ç”¨ parseBogusComment å…œåº•å¤„ç† å¦‚æœä¸ŠæŠ¥æ²¡æœ‰æŠ›å‡ºé”™è¯¯çš„è¯ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') {
    // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
    if (s.length === 1) {
      emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)
    } else if (s[1] === '!') {
      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
      if (startsWith(s, '&lt;!--')) {
        node = parseComment(context)
      } else if (startsWith(s, '&lt;!DOCTYPE')) {
        // Ignore DOCTYPE by a limitation.
        node = parseBogusComment(context)
      } else if (startsWith(s, '&lt;![CDATA[')) {
        if (ns !== Namespaces.HTML) {
          node = parseCDATA(context, ancestors)
        } else {
          emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)
          node = parseBogusComment(context)
        }
      } else {
        emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)
        node = parseBogusComment(context)
      }
    } else if (s[1] === '/') {
        ...
    } else if (/[a-z]/i.test(s[1])) {
      ...
    } else if (s[1] === '?') {
     ...
    } else {
     ...
    }
}
</code></pre></div><p>æ¥ä¸‹æ¥ï¼Œå…ˆè®²è®² <code>!</code> å¼€å¤´ç”¨åˆ°çš„å‡ ä¸ªè§£æå‡½æ•°ï¼ŒparseComment ã€parseBogusComment å’Œ parseCDATAã€‚</p> <p>å…ˆçœ‹çœ‹ parseCommentï¼Œ å…ˆæ–­è¨€æ˜¯å¦ç¬¦åˆæ³¨é‡Šï¼Œæ¥ç€ç”¨æ­£åˆ™åŒ¹é…æ³¨é‡Šçš„ç»“å°¾ï¼Œå¦‚æœåŒ¹é…ä¸åˆ°ï¼Œåˆ™æ¶ˆè´¹å®Œå‰©ä¸‹çš„sourceï¼ŒåŒæ—¶ä¸ŠæŠ¥ <code>EOF_IN_COMMENT</code> é”™è¯¯ã€‚å¦‚æœ <code>match.index &lt;= 3</code>, è¯´æ˜åŒ¹é…åˆ°çš„ <code>--</code> æ˜¯æ³¨é‡Šå¼€å¤´çš„ <code>--</code>, ä¸ŠæŠ¥<code>ABRUPT_CLOSING_OF_EMPTY_COMMENT</code>,å¦‚æœåˆ†ç»„1æœ‰æœ‰å€¼ï¼Œä¸ŠæŠ¥ <code>INCORRECTLY_CLOSED_COMMENT</code>,æ³¨é‡Šç»“å°¾ä¸å…è®¸æœ‰æ„Ÿå¹å·ã€‚æ¥ç€åˆ¤æ–­æ³¨é‡Šé‡Œé¢æœ‰æ²¡æœ‰åµŒå¥—æ³¨é‡Šï¼Œæœ‰çš„è¯ï¼Œä¹Ÿè¦ä¸ŠæŠ¥ <code>NESTED_COMMENT</code>ï¼Œè‡³äº<code>advanceBy(context, nestedIndex - prevIndex + 1)</code> ä¸ºä»€ä¹ˆè¦åŠ 1å‘¢ï¼Œå› ä¸º prevIndex æ˜¯ context ä¸­ä½ç½®çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œæ‰€ä»¥éœ€è¦åœ¨ä¿®å¤æ­£ç¡®çš„é•¿åº¦è¦åŠ 1ã€‚æœ€åè¿”å› type ä¸º NodeTypes.COMMENTï¼Œ content ä¸ºæ³¨é‡Šå†…å®¹çš„ AST èŠ‚ç‚¹ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseComment(context: ParserContext): CommentNode {
  __TEST__ &amp;&amp; assert(startsWith(context.source, '&lt;!--'))

  const start = getCursor(context)
  let content: string

  // Regular comment.
  const match = /--(\!)?&gt;/.exec(context.source)
  if (!match) {
    content = context.source.slice(4)
    advanceBy(context, context.source.length)
    emitError(context, ErrorCodes.EOF_IN_COMMENT)
  } else {
    if (match.index &lt;= 3) {
      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)
    }
    if (match[1]) {
      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)
    }
    content = context.source.slice(4, match.index)

    // Advancing with reporting nested comments.
    const s = context.source.slice(0, match.index)
    let prevIndex = 1,
      nestedIndex = 0
    while ((nestedIndex = s.indexOf('&lt;!--', prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1)
      if (nestedIndex + 4 &lt; s.length) {
        emitError(context, ErrorCodes.NESTED_COMMENT)
      }
      prevIndex = nestedIndex + 1
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1)
  }

  return {
    type: NodeTypes.COMMENT,
    content,
    loc: getSelection(context, start)
  }
}
</code></pre></div><p>å†çœ‹çœ‹ parseBogusCommentï¼Œä¹Ÿæ˜¯ä¸€å¼€å§‹ç”¨æ­£åˆ™å»åˆ¤æ–­å¼€å¤´æ˜¯å¦ç¬¦åˆï¼Œè¿™ä¸ªæ­£åˆ™æœ‰ç‚¹æ„æ€ï¼Œå°±æ˜¯å¼€å¤´<code>&lt;</code>, ä¸­é—´æˆ–è€…æ˜¯ <code>!</code> æˆ–è€… <code>?</code> æˆ–è€…æ˜¯ <code>/</code> åé¢è·Ÿç€ä¸æ˜¯ a åˆ° zã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseBogusComment(context: ParserContext): CommentNode | undefined {
  __TEST__ &amp;&amp; assert(/^&lt;(?:[\!\?]|\/[^a-z&gt;])/i.test(context.source))

  const start = getCursor(context)
  const contentStart = context.source[1] === '?' ? 1 : 2
  let content: string

  const closeIndex = context.source.indexOf('&gt;')
  if (closeIndex === -1) {
    content = context.source.slice(contentStart)
    advanceBy(context, context.source.length)
  } else {
    content = context.source.slice(contentStart, closeIndex)
    advanceBy(context, closeIndex + 1)
  }

  return {
    type: NodeTypes.COMMENT,
    content,
    loc: getSelection(context, start)
  }
}
</code></pre></div><p>æˆ‘ä»¬å¯ä»¥å¾ªç¯é‚£é‡Œçœ‹çœ‹ bogusComment çš„é€‚ç”¨èŒƒå›´ã€‚DOCTYPE ã€CDATA åœ¨ Namespaces.HTML å‘½åç©ºé—´æ—¶ã€<code>&lt;ï¼</code>å¼€å¤´çš„å…œåº•ã€s[1] ä¸º <code>/</code> ä¸” s[2] ä¸ä¸º <code>[a-z]</code>, <code>&lt;?</code>å¼€å¤´çš„ã€‚è¿™ä¹ˆä¸€è§£é‡Šï¼Œæ˜¯ä¸æ˜¯ä¸Šé¢çš„æ­£åˆ™å°±å¥½ç†è§£äº†ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>else if (s[1] === '!') {
  // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
  if (startsWith(s, '&lt;!--')) {
    node = parseComment(context)
  } else if (startsWith(s, '&lt;!DOCTYPE')) {
    // Ignore DOCTYPE by a limitation.
    node = parseBogusComment(context)
  } else if (startsWith(s, '&lt;![CDATA[')) {
    if (ns !== Namespaces.HTML) {
      node = parseCDATA(context, ancestors)
    } else {
      emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)
      node = parseBogusComment(context)
    }
  } else {
    emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)
    node = parseBogusComment(context)
  }
} else if (s[1] === '/') {
  // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
  if (s.length === 2) {
    emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)
  } else if (s[2] === '&gt;') {
    emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)
    advanceBy(context, 3)
    continue
  } else if (/[a-z]/i.test(s[2])) {
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  } else {
    emitError(
      context,
      ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,
      2
    )
    node = parseBogusComment(context)
  }
} else if (/[a-z]/i.test(s[1])) {
  node = parseElement(context, ancestors)
} else if (s[1] === '?') {
  emitError(
    context,
    ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,
    1
  )
  node = parseBogusComment(context)
} else {
  emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)
}
</code></pre></div><p>é‚£æˆ‘ä»¬å›åˆ° parseBogusComment ç»§ç»­è®²è§£ã€‚å¯¹äº <code>context.source[1] === '?'</code> ä¸º trueï¼Œ æ³¨é‡Šçš„å†…å®¹åŒ…å« <code>?</code>ï¼Œå¦åˆ™ä¸åŒ…å«ã€‚ç„¶åå¯»æ‰¾ç»“æŸæ ‡ç­¾<code>&gt;</code>ï¼Œæ‰¾ä¸åˆ°æ¶ˆè´¹å…¨éƒ¨çš„ sourceã€‚å¯¹äº closeIndex + 1, å› ä¸ºè¿™æ‰æ˜¯æ•´ä¸ªæ³¨é‡Šçš„é•¿åº¦ã€‚</p> <p>æ¥ä¸‹æ¥è®²è§£ parseCDATAã€‚ä¸€å¼€å§‹ä¹Ÿæ˜¯ä¸¤ä¸ªæ–­è¨€ï¼Œç¥–å…ˆä¸èƒ½ä¸ºç©ºï¼Œç¥–å…ˆçš„å‘½åç©ºé—´ä¸èƒ½æ˜¯ Namespaces.HTMLï¼Œç„¶åä¹Ÿæ˜¯è¦æ±‚ <code>&lt;![CDATA[</code> å¼€å¤´çš„ã€‚æ¥ç€å¾€å‰æ¨è¿› contextï¼Œåœ¨é‡Œé¢åµŒå¥—è°ƒç”¨ parseChildrenï¼Œ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™æ˜¯çš„ <code>ancestors</code> æ²¡æœ‰å…ƒç´ è¿›æ ˆï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰æ”¹å˜å‘½åç©ºé—´ï¼Œç¬¬äºŒæ˜¯è§£ææ¨¡å¼æ˜¯ <code>TextModes.CDATA</code>ï¼Œè¿™æ„å‘³ç€è¿™ä¸ªåµŒå¥— parseChildren é‡Œé¢åªæ˜¯è°ƒç”¨ parseText å»è§£æèŠ‚ç‚¹ã€‚åŒæ—¶è¿”å›æ¥çš„å†…å®¹å¯èƒ½åŒ…å«å¤šä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¹Ÿæ˜¯ parseChildren çš„å¾ªç¯é‡Œé¢éœ€è¦åˆ¤æ–­è¿”å›çš„èŠ‚ç‚¹æ˜¯å¦æ˜¯æ•°ç»„çš„åŸå› äº†ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseCDATA(
  context: ParserContext,
  ancestors: ElementNode[]
): TemplateChildNode[] {
  __TEST__ &amp;&amp;
    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)
  __TEST__ &amp;&amp; assert(startsWith(context.source, '&lt;![CDATA['))

  advanceBy(context, 9)
  const nodes = parseChildren(context, TextModes.CDATA, ancestors)
  if (context.source.length === 0) {
    emitError(context, ErrorCodes.EOF_IN_CDATA)
  } else {
    __TEST__ &amp;&amp; assert(startsWith(context.source, ']]&gt;'))
    advanceBy(context, 3)
  }

  return nodes
}
</code></pre></div><p>å›åˆ°å¾ªç¯, å½“ <code>s[1]</code> æ˜¯ <code>/</code> æ—¶ï¼Œ å¦‚æœé•¿åº¦å°±ä¸º2ï¼Œä¸ŠæŠ¥ <code>EOF_BEFORE_TAG_NAME</code> é”™è¯¯ï¼Œçœ‹è‹±æ–‡éƒ½å¤§æ¦‚çŸ¥é“å•¥æ„æ€äº†ï¼Œæ²¡æ‰¾åˆ° tag å°±ç»“æŸäº†ã€‚å¦‚æœ <code>s[2] === '&gt;'</code>ï¼Œ ä¸ŠæŠ¥ <code>MISSING_END_TAG_NAME</code> é”™è¯¯ï¼Œ å¾€å‰æ¨è¿›3é•¿åº¦ï¼Œå¦‚æœ emitError ä¸æŠ›å‡ºé”™è¯¯çš„è¯ï¼Œç›¸å½“äºè§£æå™¨å®¹å¿è¿™ä¸ªé”™è¯¯ï¼Œ continue ç»§ç»­è§£æã€‚å¦‚æœ <code>/[a-z]/i.test(s[2])</code> æˆç«‹ï¼Œå°±æ˜¯ç±»ä¼¼ <code>&lt;/div&gt;</code>ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“ html æ ‡ç­¾è¦ä¹ˆæ˜¯æˆå¯¹å‡ºç°æˆ–è€… Void Tag,è€Œè¿™ç§æƒ…å†µä¼šåœ¨ä¸‹é¢ parseElement è¢«å¤„ç†ï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ŠæŠ¥ <code>X_INVALID_END_TAG</code> é”™è¯¯ï¼Œ å¹¶ä¸”è°ƒç”¨ parseTag è§£æèŠ‚ç‚¹ã€‚æœ€åï¼Œå¦‚æœå‰é¢çš„åˆ¤æ–­éƒ½ä¸æ»¡è¶³ï¼Œå°±æ‰å…¥å‰é¢æ‰€è¯´çš„ parseBogusComment ä¸­æ­£åˆ™åŒ¹é…çš„æœ€åä¸€é¡¹ï¼ŒåŒæ—¶ä¸ŠæŠ¥ <code>INVALID_FIRST_CHARACTER_OF_TAG_NAME</code> é”™è¯¯ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>else if (s[1] === '/') {
  // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
  if (s.length === 2) {
    emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)
  } else if (s[2] === '&gt;') {
    emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)
    advanceBy(context, 3)
    continue
  } else if (/[a-z]/i.test(s[2])) {
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  } else {
    emitError(
      context,
      ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,
      2
    )
    node = parseBogusComment(context)
  }
}
</code></pre></div><p>å›åˆ°å¾ªç¯ï¼Œ<code>else if (s[1] === '/') {</code> åˆ†æ”¯è®²è§£å®Œæ¯•ï¼Œæ¥ä¸‹æ¥è®² <code>/[a-z]/i.test(s[1])</code> åˆ†æ”¯ã€‚è¿™ä¸ªåˆ†æ”¯ï¼Œå°±æ˜¯æ•´å„¿å…«ç»åœ°å¤„ç†æ ‡ç­¾çš„åˆ†æ”¯äº†ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>else if (/[a-z]/i.test(s[1])) {
  node = parseElement(context, ancestors)
}
</code></pre></div><p>ä¸‹é¢å°±æ˜¯ parseElement å‡½æ•°ã€‚è¿˜æ˜¯å¼€å±€æ–­è¨€æ˜¯ä¸æ˜¯ç¬¦åˆ Element çš„å¼€å¤´ï¼ŒwasInPre ã€wasInVPre éƒ½æ˜¯ä¸ºäº†ä¿å­˜å½“å‰çš„ pre çŠ¶æ€ï¼Œå› ä¸ºä¸‹é¢è§£æ parseTag çš„æ—¶å€™ context ä¸Šçš„å€¼ä¼šæ”¹å˜ï¼Œè€Œå¦‚æœè§£æå inPre æˆ–è€… inVPre å˜ä¸º trueï¼Œè€Œä»¥å‰æ˜¯ falseï¼Œå°±è¯´æ˜å½“å‰æ ‡ç­¾æ˜¯ pre æˆ–è€… v-pre çš„è¾¹ç•Œç‚¹ï¼Œä¹Ÿå°±æ˜¯ç”±å®ƒå¼€å¯çš„ï¼Œåœ¨ parseElement çš„æœ€åä¹Ÿè¦æ¢å¤æˆåŸæ¥çš„çŠ¶æ€ã€‚æˆ‘ä»¬çœ‹åˆ° parseElement ç”¨åˆ°äº† parseTag å»è§£ææ ‡ç­¾ï¼Œé‚£ä¹ˆè·Ÿç€æ­¥ä¼ï¼Œå»çœ‹çœ‹ parseTagã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseElement(
  context: ParserContext,
  ancestors: ElementNode[]
): ElementNode | undefined {
  __TEST__ &amp;&amp; assert(/^&lt;[a-z]/i.test(context.source))

  // Start tag.
  const wasInPre = context.inPre
  const wasInVPre = context.inVPre
  const parent = last(ancestors)
  const element = parseTag(context, TagType.Start, parent)
  const isPreBoundary = context.inPre &amp;&amp; !wasInPre
  const isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre

  ...

  if (isPreBoundary) {
    context.inPre = false
  }
  if (isVPreBoundary) {
    context.inVPre = false
  }
  return element
}

</code></pre></div><p>parseTag ä¸ä»…ä»…ç”¨äºåœ¨ parseElement ä¸­è§£ææ ‡ç­¾ï¼ŒåŒæ—¶æˆ‘ä»¬åœ¨ä¸Šé¢è®²è¿‡ä¸€äº›æƒ…å†µè¿›è¡Œå…œåº•ï¼Œå°±æ˜¯åªæœ‰ç»“æŸæ ‡ç­¾çš„æƒ…å†µã€‚</p> <p>å¯ä»¥çœ‹åˆ°ä¸€ä¸Šæ¥ä¹Ÿæ˜¯å…ˆå¯¹æˆ‘ä»¬çš„å­—ç¬¦ä¸²è¿›è¡Œæ–­è¨€ï¼ŒåŒæ—¶åˆ¤æ–­æˆ‘ä»¬çš„å­—ç¬¦ä¸²æ˜¯å¦è·Ÿæˆ‘ä»¬è¦è§£æçš„ TagType æ¨¡å¼æ˜¯å¦åŒ¹é…ï¼Œæ€»ä¸èƒ½ä½ ä¼ è¿›æ¥å¼€å§‹çš„tagï¼Œå‘Šè¯‰æˆ‘è¿™æ˜¯ç»“æŸæ¨¡å¼ã€‚</p> <p>æ¥ç€æ‹¿åˆ°å¼€å§‹ä½ç½® startã€æ­£åˆ™å»åŒ¹é…æ ‡ç­¾ã€æ‹¿åˆ° tagã€æ‹¿åˆ°å½“å‰æ ‡ç­¾æ‰€å¤„çš„å‘½åç©ºé—´ï¼ˆè¿™ä¸ªæ˜¯ options ä¼ è¿›æ¥çš„ï¼‰ï¼Œéœ€è¦æ³¨æ„æ­£åˆ™ä¸­ tag å¼€å¤´åªèƒ½æ˜¯ <code>[a-z]</code>, å¹²å®Œè¿™äº›ï¼Œæˆ‘ä»¬å¼€å§‹å¾€å‰æ¨è¿› contextï¼Œæ¶ˆè€—æ ‡ç­¾ã€æ¶ˆè€—ç©ºæ ¼ï¼Œç›®çš„å°±æ˜¯ä¸ºäº†æˆ‘ä»¬ä¸‹é¢è¿›è¡Œæ ‡ç­¾å±æ€§çš„è§£æï¼Œç„¶åä¿å­˜å½“å‰çš„ä½ç½®å’Œå­—ç¬¦ä¸²ï¼Œå› ä¸ºå¦‚æœåé¢è§£æå±æ€§è¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°äº† v-pre æ ‡ç­¾ï¼Œéœ€è¦é‡æ–°è§£ææ ‡ç­¾å±æ€§ï¼Œè‡³äºä¸ºä»€ä¹ˆè¦è¿™æ ·åšå‘¢ï¼Œåé¢ä¼šè®²åˆ°ã€‚</p> <p>å¯ä»¥çœ‹åˆ°ï¼Œåœ¨ parseTag é‡Œé¢ï¼Œåˆè°ƒç”¨äº† parseAttributes å»è§£ææ ‡ç­¾çš„å±æ€§ï¼Œprops æ˜¯æˆ‘ä»¬è§£æå›æ¥çš„å±æ€§æ•°ç»„ã€‚æ¥ç€æˆ‘ä»¬åˆæ ¡éªŒæ˜¯ä¸æ˜¯ isPreTagï¼Œè¿™ä¸ªæ ¡éªŒæ–¹æ³•æ˜¯ä» options é€ä¼ ä¸‹æ¥çš„ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥çœ‹åˆ° context åœ¨è§£æè¿‡ç¨‹ä¸­ä¸€ç›´å¤„äºå˜åŒ–è¿‡ç¨‹çš„ã€‚æ¥ä¸‹æ¥å…³é”®çš„ä¸€æ­¥æ¥äº†ï¼Œå¦‚æœä»¥å‰ä¸æ˜¯ isInPre ä½†æ˜¯è§£æå‡ºæ¥çš„ props æœ‰ v-pre æŒ‡ä»¤ï¼Œå¦‚æœæœ‰,context.isInPre å°±ä¸º true çŠ¶æ€ï¼Œæœ€é‡è¦çš„æ˜¯ï¼Œæ¢å¤è§£æ props ä¹‹å‰çš„ source å’Œ ä½ç½®ï¼Œæˆ‘ä»¬è¦é‡æ–°è§£æ propsï¼Œå¯ä»¥é€éœ²çš„ä¸€ç‚¹æ˜¯ï¼Œè¿™ä¸ªå½±å“åˆ°æˆ‘ä»¬éœ€ä¸éœ€è¦å¯¹å†…ç½®çš„ä¸€äº›æŒ‡ä»¤è¿›è¡ŒäºŒæ¬¡è½¬åŒ–ï¼Œå¦‚æœæ˜¯å¤„äº v-pre ç¯å¢ƒä¸‹æ¥ï¼Œé‚£ä¹ˆåˆ™ä¸éœ€è¦è½¬åŒ–ï¼Œè¿™ä¸ªåé¢ç»†è®²ã€‚</p> <p>æˆ‘ä»¬è¦çœ‹çœ‹è¿™ä¸ªæ ‡ç­¾æ˜¯å¦æ­£ç¡®å…³é—­ï¼Œsource æ²¡äº†ï¼Œè‚¯å®šä¸è¡Œï¼Œä¸ŠæŠ¥ <code>EOF_IN_TAG</code>, å¦‚æœæˆ‘ä»¬è§£æçš„æ˜¯ç»“æŸæ ‡ç­¾ï¼Œåˆç¢°åˆ°äº†è‡ªé—­åˆçš„å­—ç¬¦ <code>/&gt;</code>ï¼Œä¹Ÿä¸è¡Œå•Šï¼Œä¸ŠæŠ¥ <code>END_TAG_WITH_TRAILING_SOLIDUS</code>, åŒæ—¶å¾€å‰æ¨è¿› contextã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>/**
 * Parse a tag (E.g. `&lt;div id=a&gt;`) with that type (start tag or end tag).
 */
function parseTag(
  context: ParserContext,
  type: TagType,
  parent: ElementNode | undefined
): ElementNode {
  __TEST__ &amp;&amp; assert(/^&lt;\/?[a-z]/i.test(context.source))
  __TEST__ &amp;&amp;
    assert(
      type === (startsWith(context.source, '&lt;/') ? TagType.End : TagType.Start)
    )

  // Tag open.
  const start = getCursor(context)
  const match = /^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i.exec(context.source)!
  const tag = match[1]
  const ns = context.options.getNamespace(tag, parent)

  advanceBy(context, match[0].length)
  advanceSpaces(context)

  // save current state in case we need to re-parse attributes with v-pre
  const cursor = getCursor(context)
  const currentSource = context.source

  // Attributes.
  let props = parseAttributes(context, type)

  // check &lt;pre&gt; tag
  if (context.options.isPreTag(tag)) {
    context.inPre = true
  }

  // check v-pre
  if (
    !context.inVPre &amp;&amp;
    props.some(p =&gt; p.type === NodeTypes.DIRECTIVE &amp;&amp; p.name === 'pre')
  ) {
    context.inVPre = true
    // reset context
    extend(context, cursor)
    context.source = currentSource
    // re-parse attrs and filter out v-pre itself
    props = parseAttributes(context, type).filter(p =&gt; p.name !== 'v-pre')
  }

  // Tag close.
  let isSelfClosing = false
  if (context.source.length === 0) {
    emitError(context, ErrorCodes.EOF_IN_TAG)
  } else {
    isSelfClosing = startsWith(context.source, '/&gt;')
    if (type === TagType.End &amp;&amp; isSelfClosing) {
      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)
    }
    advanceBy(context, isSelfClosing ? 2 : 1)
  }

  ...
  
  return {
    type: NodeTypes.ELEMENT,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined // to be created during transform phase
  }
}

</code></pre></div><p>parseTag è§£æå®Œå±æ€§ã€æ ‡ç­¾ï¼Œæ¥ä¸‹æ¥å°±è¦åˆ¤æ–­è¿™ä¸ª Tag æ ‡ç­¾çš„ tagType äº†ï¼Œæ³¨æ„æˆ‘ä»¬è·Ÿ AST çš„ type åŒºåˆ«å¼€æ¥ï¼Œtype åªæ˜¯åŒºåˆ«è¿™ä¸ª AST å¤§è‡´æ˜¯ä»€ä¹ˆç±»å‹ï¼Œ tagType æ˜¯ç»†åˆ†åˆ°æˆ‘ä»¬è¿™ä¸ªå±äº ElementTypes çš„ä»€ä¹ˆç±»å‹ï¼Œè¿™å¯¹äºåç»­ diff å’Œ transform ç­‰å¾ˆå¤šåœ°æ–¹èµ·åˆ°å¾ˆå¤§çš„ä½œç”¨ã€‚</p> <p>åº·åº·ä¸‹é¢ï¼Œé»˜è®¤çš„ tagType æ˜¯ ElementTypes.ELEMENTï¼Œç„¶åå¼€å¯æˆ‘ä»¬çš„åˆ¤æ–­ï¼Œä¹Ÿæ˜¯ v-pre åˆ™è·³è¿‡åˆ¤æ–­ï¼Œä½†è¿˜æœ‰ä¸€ä¸ªç‚¹å°±æ˜¯ isCustomElement è‡ªå®šä¹‰æ ‡ç­¾ï¼Œè¿™ä¸ªå¸¸è§çš„ç”¨æ³•å°±æ˜¯æˆ‘ä»¬çš„è‡ªå®šä¹‰çš„ WebComponentã€‚</p> <p>å¦‚æœè¿›å…¥äº†ç¬¬ä¸€å±‚åˆ¤æ–­ï¼Œæˆ‘ä»¬é¦–å…ˆå»æœå¯»æœ‰æ²¡æœ‰ is æŒ‡ä»¤ï¼Œå¯¹äºä¸æ˜¯å¹³å°åŸç”Ÿ tag ä¸”æ²¡æœ‰ is æŒ‡ä»¤çš„ï¼Œæˆ‘ä»¬è®¤ä¸º tagType æ˜¯ ElementTypes.COMPONENTã€‚å¯¹äº dom å¹³å°ï¼Œ
åŸç”Ÿ tag å°±æ˜¯ <code>isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag)</code>ã€‚</p> <p>è€Œå¦‚æœæœ‰ is æŒ‡ä»¤ ã€æ¡†æ¶æ ¸å¿ƒç»„ä»¶ã€å¹³å°å†…å»ºç»„ä»¶ã€å¤§å†™å¼€å¤´çš„æ ‡ç­¾ã€tag æ˜¯ component çš„ï¼Œæˆ‘ä»¬éƒ½è®¤ä¸ºæ˜¯ ElementTypes.COMPONENTã€‚å¤§å†™å¼€å¤´çš„æ ‡ç­¾ï¼Œè¿™ä¸ªæˆ‘ä»¬å†™è¿‡ vue éƒ½çŸ¥é“äº†ï¼Œtag æ˜¯ component æ›´ä¸è¦è¯´äº†ã€‚æ¡†æ¶æ ¸å¿ƒç»„ä»¶å°±æ˜¯åŒ…æ‹¬äº† Teleportã€Suspenseã€KeepAliveã€BaseTransitionï¼Œä½ å¯ä»¥è®¤ä¸ºæ˜¯ä¸å¹³å°æ— å…³çš„å†…ç½®ç»„ä»¶ï¼Œè€Œå¹³å°å†…å»ºç»„ä»¶å°±æ˜¯ Transitionã€ TransitionGroupã€‚</p> <p>å¯¹äº tag ä¸º slotï¼Œæˆ‘ä»¬æ ‡è¯†ä¸º ElementTypes.SLOTï¼Œ å—¯è¦ç‰¹æ®Šå¤„ç†ã€‚</p> <p>è€Œå¯¹äº tag ä¸º templateçš„ï¼Œåªæœ‰å®ƒæœ‰ <code>if,else,else-if,for,slot</code> è¿™äº›æŒ‡ä»¤ï¼Œæˆ‘ä»¬åœ¨è®¤ä¸ºä»–æ˜¯ ElementTypes.TEMPLATEã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>let tagType = ElementTypes.ELEMENT
const options = context.options
if (!context.inVPre &amp;&amp; !options.isCustomElement(tag)) {
    const hasVIs = props.some(
      p =&gt; p.type === NodeTypes.DIRECTIVE &amp;&amp; p.name === 'is'
    )
    if (options.isNativeTag &amp;&amp; !hasVIs) {
      if (!options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT
    } else if (
      hasVIs ||
      isCoreComponent(tag) ||
      (options.isBuiltInComponent &amp;&amp; options.isBuiltInComponent(tag)) ||
      /^[A-Z]/.test(tag) ||
      tag === 'component'
    ) {
      tagType = ElementTypes.COMPONENT
    }
    
    if (tag === 'slot') {
      tagType = ElementTypes.SLOT
    } else if (
      tag === 'template' &amp;&amp;
      props.some(p =&gt; {
        return (
          p.type === NodeTypes.DIRECTIVE &amp;&amp; isSpecialTemplateDirective(p.name)
        )
      })
    ) {
      tagType = ElementTypes.TEMPLATE
    }
}

export function isCoreComponent(tag: string): symbol | void {
  if (isBuiltInType(tag, 'Teleport')) {
    return TELEPORT
  } else if (isBuiltInType(tag, 'Suspense')) {
    return SUSPENSE
  } else if (isBuiltInType(tag, 'KeepAlive')) {
    return KEEP_ALIVE
  } else if (isBuiltInType(tag, 'BaseTransition')) {
    return BASE_TRANSITION
  }
}

isBuiltInComponent: (tag: string): symbol | undefined =&gt; {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP
    }
},

const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(
  `if,else,else-if,for,slot`
)

</code></pre></div><p>å›åˆ° parseTag æ”¶å°¾ï¼Œæœ€åè¿”å› AST ç±»å‹ä¸º NodeTypes.ELEMENTï¼ŒcodegenNode åœ¨ transform é˜¶æ®µçš„ transformElement æ—¶ä¼šç”Ÿæˆï¼Œ children æ˜¯ä»–ä¸‹ä¸€çº§çš„ node çš„æŒ‚è½½ç‚¹ã€‚å¯¹äº parseTag ï¼Œæœ‰ä¸¤ä¸ªç‚¹è¿˜éœ€è¦è¡¥å……ï¼Œä¸€ä¸ªæ˜¯ getNamespace ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯ parseAttributesã€‚å†æ¬¡æé†’çš„æ˜¯ï¼Œæˆ‘ä»¬è¿˜åœ¨ parseElement é‡Œé¢è¿˜æ²¡æ¸¸å‡ºæ¥å‘¢ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>return {
    type: NodeTypes.ELEMENT,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined // to be created during transform phase
}
</code></pre></div><p>getNamespace ä¸»è¦æ˜¯å¯¹ä¸ºäº†è·å–æ­£ç¡®çš„å‘½åç©ºé—´ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨ä¸Šé¢ä¸€ç›´è¯´çš„ï¼Œä¸åŒçš„å‘½åç©ºé—´ä¼šå¯¹è§£ææ˜¯æœ‰å½±å“çš„ï¼Œå¯¹äº dom å¹³å°æ¥è¯´ï¼Œç›®å‰å°±ä¸‰ç§å‘½åç©ºé—´ï¼Œ<code>DOMNamespaces.HTML</code> html å‘½åç©ºé—´ï¼Œ<code>DOMNamespaces.MATH_ML</code> math ml å‘½åç©ºé—´ï¼Œ<code>DOMNamespaces.SVG</code> svg å‘½åç©ºé—´ã€‚</p> <p>åœ¨ getNamespace å†…éƒ¨ï¼Œé¦–å…ˆæ‹¿åˆ°çˆ¶çº§çš„å‘½åç©ºé—´ï¼Œé»˜è®¤æ˜¯ DOMNamespaces.HTMLã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæ²¡æœ‰æˆ‘ä»¬æ²¡æœ‰å¯¹ ns å˜é‡è¿›è¡Œè¦†ç›–æˆ–è€…æå‰ returnï¼Œåˆ™è¯´æ˜å½“å‰ tag çš„ ns è·Ÿ çˆ¶çº§çš„ ns ä¸€æ ·ï¼Œå› ä¸ºå‡½æ•°æœ€åçš„æŠŠ ns è¿”å›å»çš„ã€‚</p> <p>æ¥ä¸‹æ¥å°†é’ˆå¯¹çˆ¶çº§å­˜åœ¨çš„æƒ…å†µä¸‹è¿›è¡Œè§£æï¼Œå¦‚æœçˆ¶çº§ ns æ˜¯ MATH_ML ä¸” çˆ¶çº§æ ‡ç­¾æ˜¯ <code>annotation-xml</code> ï¼Œè¿™æ—¶å½“å‰æ ‡ç­¾æ˜¯ <code>svg</code>ï¼Œæˆ‘ä»¬è®¤ä¸ºæ˜¯å¤„äº svg çš„ nsï¼Œè€Œè¿™æ—¶æ ‡ç­¾ä¸æ˜¯ svg ä½†æ˜¯çˆ¶çº§ annotation-xml æ ‡ç­¾çš„ å±æ€§é‡Œé¢æœ‰ç”³æ˜ä¸‹é¢æ˜¯ html å³ <code>text/html</code> æˆ– <code>application/xhtml+xml</code>ï¼Œ æˆ‘ä»¬ä¹Ÿè®¤ä¸ºæ˜¯ HTML çš„ nsã€‚å¯¹äºçˆ¶çº§æ ‡ç­¾ ä¸æ˜¯<code>annotation-xml</code> ï¼Œä¸”<code>/^m(?:[ions]|text)$/.test(parent.tag) &amp;&amp; tag !== 'mglyph' &amp;&amp; tag !== 'malignmark'</code>,æˆ‘ä»¬è¿˜æ˜¯è®¤ä¸ºåœ¨ HTML çš„ nsã€‚å¦‚æœä¸Šé¢æ¡ä»¶éƒ½ä¸æ»¡è¶³ï¼Œ MATH_ML è¿™ä¸ª ns è®²ä¼ é€’ç»™å½“å‰ tagã€‚</p> <p>è€Œå¯¹äºçˆ¶çº§æ˜¯ SVG çš„ nsï¼Œåªæœ‰çˆ¶çº§ tag æ˜¯ <code>parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title'</code> è¿™äº› tag çš„æ—¶å€™ï¼Œå½“å‰ tag æ‰ç®—åœ¨ HTML çš„nsï¼Œå¦åˆ™ç»§ç»­ SVG çš„ nsã€‚</p> <p>æœ€åå¯¹äºçˆ¶çº§ ns ä¸º HTML çš„å¤„ç†ï¼Œä¸»è¦å½“å‰ tag æ˜¯ <code>svg</code> æˆ–è€… <code>math</code>, åˆ™ä¼šå˜åŒ– ns ä¸º SVG æˆ–è€… MATH_MLã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>// https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {
    let ns = parent ? parent.ns : DOMNamespaces.HTML

    if (parent &amp;&amp; ns === DOMNamespaces.MATH_ML) {
      if (parent.tag === 'annotation-xml') {
        if (tag === 'svg') {
          return DOMNamespaces.SVG
        }
        if (
          parent.props.some(
            a =&gt;
              a.type === NodeTypes.ATTRIBUTE &amp;&amp;
              a.name === 'encoding' &amp;&amp;
              a.value != null &amp;&amp;
              (a.value.content === 'text/html' ||
                a.value.content === 'application/xhtml+xml')
          )
        ) {
          ns = DOMNamespaces.HTML
        }
      } else if (
        /^m(?:[ions]|text)$/.test(parent.tag) &amp;&amp;
        tag !== 'mglyph' &amp;&amp;
        tag !== 'malignmark'
      ) {
        ns = DOMNamespaces.HTML
      }
    } else if (parent &amp;&amp; ns === DOMNamespaces.SVG) {
      if (
        parent.tag === 'foreignObject' ||
        parent.tag === 'desc' ||
        parent.tag === 'title'
      ) {
        ns = DOMNamespaces.HTML
      }
    }

    if (ns === DOMNamespaces.HTML) {
      if (tag === 'svg') {
        return DOMNamespaces.SVG
      }
      if (tag === 'math') {
        return DOMNamespaces.MATH_ML
      }
    }
    return ns
},
</code></pre></div><p>OKï¼Œé‚£ç°åœ¨å°±è®²è®² parseAttributes ï¼Œçœ‹çœ‹æ˜¯æ€ä¹ˆè§£æå±æ€§çš„ï¼Œä¹Ÿåœ¨è¿™é‡Œæ­ç§˜ä¸ºä»€ä¹ˆ v-pre è¦é‡æ–°è§£æä¸€æ¬¡å±æ€§ã€‚ props æ˜¯æœ€åè¿”å›å»çš„å±æ€§æ•°ç»„ï¼ŒåŒæ—¶ç»´æŠ¤ä¸€ä¸ª attributeNames ç”¨äºè§£æå±æ€§è¿‡ç¨‹ä¸­è¿›è¡Œå»é‡æ ¡éªŒã€‚æ¥ä¸‹æ¥ï¼Œä¹Ÿæ˜¯ä¸€ä¸ª while ä¸æ–­å»è¯»å–å­—ç¬¦ä¸²ï¼Œå¦‚æœ source æ¶ˆè€—å®Œæ¯• åˆæˆ–è€…é‡åˆ°äº†æ ‡ç­¾ç»“æŸçš„ç¬¦å· <code>&gt;</code> æˆ– <code>/&gt;</code>, æ‰é€€å‡ºå¾ªç¯ã€‚ è¿›å»å¾ªç¯åï¼Œå¦‚æœä¸€å¼€æ³¢å°±ç»™æˆ‘ä»¬ä¸€ä¸ª <code>/</code>ï¼Œä¸ŠæŠ¥ <code>UNEXPECTED_SOLIDUS_IN_TAG</code> é”™è¯¯ï¼Œå¾€å‰æ¨è¿› context åŒæ—¶æ¶ˆè€—ç©ºæ ¼ã€‚å¦‚æœè¦å¼€å§‹è§£æå…·ä½“å±æ€§äº†ï¼Œä½†æ˜¯ type æ˜¯ <code>TagType.End</code>ï¼Œè¿™ä¹Ÿä¸è¡Œï¼Œä¸èƒ½åœ¨ç»“æŸæ ‡ç­¾å¸¦å±æ€§ï¼Œä¸ŠæŠ¥ <code>END_TAG_WITH_ATTRIBUTES</code>  é”™è¯¯ã€‚æ¥ç€ä½¿ç”¨ parseAttribute å»è§£æå…·ä½“æŸä¸ªå±æ€§ï¼Œè§£ææˆåŠŸåï¼Œå†æ¬¡æ ¡éªŒæ˜¯å¦æ˜¯ TagType.Startï¼Œ å¦‚æœæ˜¯ï¼Œå¡å…¥ props æ•°ç»„ï¼ŒåŒæ—¶å¯¹å­—ç¬¦ä¸²è¿›è¡Œæ ¡éªŒï¼Œå¦‚æœä¸‹ä¸ªå±æ€§ä¸å½“å‰å±æ€§æ²¡æœ‰ <code>[^\t\r\n\f /&gt;]</code> è¿™äº›åšé—´éš”ï¼Œä¸ŠæŠ¥ <code>MISSING_WHITESPACE_BETWEEN_ATTRIBUTES</code> é”™è¯¯ï¼Œå°±æ˜¯ç±»ä¼¼ <code>&lt;div id=&quot;foo&quot;class=&quot;bar&quot;&gt;&lt;/div&gt;</code>, id å’Œ  class ä¹‹é—´æ²¡æœ‰é—´éš”ï¼Œå¾ªç¯æœ€åæ¶ˆè€—å­—ç¬¦ä¸²ä¸­çš„ç©ºæ ¼ã€‚å°±è¿™æ ·çš„ä¸€ä¸ªå¾ªç¯ï¼ŒæŠŠ Tag ä¸Šçš„å…¨éƒ¨æ ‡ç­¾è§£æå‡ºæ¥ï¼Œæœ€å return å‡ºå»ã€‚å½“ç„¶å…·ä½“å•ä¸ªå±æ€§çš„è§£æåœ¨ parseAttribute å‡½æ•°é‡Œé¢ï¼Œä¸‹é¢å°±è®²åˆ°ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseAttributes(
  context: ParserContext,
  type: TagType
): (AttributeNode | DirectiveNode)[] {
  const props = []
  const attributeNames = new Set&lt;string&gt;()
  while (
    context.source.length &gt; 0 &amp;&amp;
    !startsWith(context.source, '&gt;') &amp;&amp;
    !startsWith(context.source, '/&gt;')
  ) {
    if (startsWith(context.source, '/')) {
      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)
      advanceBy(context, 1)
      advanceSpaces(context)
      continue
    }
    if (type === TagType.End) {
      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)
    }

    const attr = parseAttribute(context, attributeNames)
    if (type === TagType.Start) {
      props.push(attr)
    }

    if (/^[^\t\r\n\f /&gt;]/.test(context.source)) {
      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)
    }
    advanceSpaces(context)
  }
  return props
}
</code></pre></div><p>å¯¹äºå…·ä½“å±æ€§è§£æï¼Œåˆ†æˆä¸¤éƒ¨åˆ†ï¼ŒparseAttribute å’Œ parseAttributeValueï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“å±æ€§å¤§éƒ¨åˆ†æœ‰å€¼ã€‚</p> <p>é—²è¯ä¸å¤šè¯´ï¼Œçœ‹çœ‹ parseAttributeã€‚æ–­è¨€ source å·²ç»æ€è€ƒè§æƒ¯äº†ï¼Œæ¥ç€ä¿å­˜ name çš„ä½ç½®ï¼ŒåŒæ—¶å°è¯•ç”¨æ­£åˆ™å»åŒ¹é…å­—ç¬¦ä¸²è·å–å±æ€§çš„åå­— nameï¼Œè¿™ä¸ªæ­£åˆ™ä¹Ÿæ˜¯å¾ˆå®½æ³›ï¼Œå°±æ˜¯æ’é™¤ç©ºç™½å­—ç¬¦å’Œç»“æŸå­—ç¬¦ï¼ŒåŒæ—¶å¯¹äºå±æ€§åå­—çš„ç¬¬ä¸€ä½å…è®¸ <code>=</code>ï¼Œè™½ç„¶åœ¨ä¸‹é¢ä¼šä¸ŠæŠ¥ <code>UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME</code> é”™è¯¯ï¼Œå±æ€§åå­—çš„åé¢å°±ä¸å…è®¸ <code>=</code> ç¬¦å·äº†ï¼Œæ¯•ç«Ÿè¿™æ˜¯ç”¨æ¥åˆ‡å‰²å±æ€§åå’Œå±æ€§å€¼çš„ã€‚</p> <p>nameSet å°±æ˜¯æˆ‘ä»¬åœ¨ä¸Šé¢ parseAttributes ä¼ ä¸‹æ¥çš„ set é›†åˆï¼Œå¦‚æœé‡å¤äº†ï¼Œä¸ŠæŠ¥ DUPLICATE_ATTRIBUTEã€‚è®°ç€æŠŠæˆ‘ä»¬çš„å±æ€§ååŠ å…¥ set é›†åˆé‡Œé¢ã€‚</p> <p>é™¤äº†ç­‰å·ä¸èƒ½å‡ºç°åœ¨é›†åˆåï¼Œ <code>/[&quot;'&lt;]/g</code> è¿™äº›ä¹Ÿä¸å¯ä»¥ï¼Œå¯¹äºæ£€æµ‹åˆ°çš„ï¼Œä¸ŠæŠ¥ <code>UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME</code> é”™è¯¯ã€‚</p> <p>ç»§ç»­å¾€å‰æ¨è¿›ï¼Œæ¥ç€å¼€å§‹è§£æå±æ€§å€¼ï¼Œå¯¹äºä¸€ä¸ªå±æ€§è€Œè¨€ï¼Œä¸ä¸€å®šæœ‰å±æ€§å€¼ï¼Œæ‰€ä»¥éœ€è¦æ­£åˆ™åŒ¹é…åˆ¤æ–­ä¸€ä¸‹ï¼Œæ²¡é—®é¢˜ä¹‹åï¼Œéœ€è¦ç­‰å·å‰é¢å¯èƒ½å­˜åœ¨çš„ç©ºæ ¼ã€ç­‰å·é•¿åº¦ã€ç­‰å·åé¢çš„ç©ºæ ¼ï¼Œåšå®Œè¿™äº›é¢„å¤‡åŠ¨ä½œï¼Œæ‰å¼€å§‹çœŸæ­£è°ƒç”¨ parseAttributeValue å»è§£æå±æ€§å€¼ï¼Œå½“ç„¶å¦‚æœè§£æä¸åˆ°å±æ€§å€¼ï¼Œä¸ŠæŠ¥ <code>MISSING_ATTRIBUTE_VALUE</code> é”™è¯¯ã€‚</p> <p>åœ¨ è¿”å› Attribute ä¹‹å‰ï¼Œä¼šå¯¹ directive æŒ‡ä»¤å±æ€§è¿›è¡Œè§£æï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä¸‹é¢ parseAttribute çœç•¥å·çš„åœ°æ–¹ï¼Œå‡è®¾æˆ‘ä»¬çš„å±æ€§ä¸æ˜¯æŒ‡ä»¤ï¼Œ æœ€åè¿”å›çš„ AST ç»“æ„å°±æ˜¯ç±»å‹ä¸º <code>NodeTypes.ATTRIBUTE</code>, åå­—æ˜¯å±æ€§åå­—ï¼Œ value æ˜¯ å±æ€§å€¼ AST è¡¨ç¤ºï¼Œä¹Ÿå¯èƒ½ä¸ºç©ºï¼Œå¦‚æœä¸ä¸ºç©ºï¼Œç±»å‹æ˜¯ <code>NodeTypes.TEXT</code>ï¼Œvalue é‡Œé¢çš„ value ç”¨  parseAttribute é‡Œé¢è¿”å›çš„ ast è¡¨ç¤ºã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseAttribute(
  context: ParserContext,
  nameSet: Set&lt;string&gt;
): AttributeNode | DirectiveNode {
  __TEST__ &amp;&amp; assert(/^[^\t\r\n\f /&gt;]/.test(context.source))

  // Name.
  const start = getCursor(context)
  const match = /^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/.exec(context.source)!
  const name = match[0]

  if (nameSet.has(name)) {
    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)
  }
  nameSet.add(name)

  if (name[0] === '=') {
    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)
  }
  {
    const pattern = /[&quot;'&lt;]/g
    let m: RegExpExecArray | null
    while ((m = pattern.exec(name))) {
      emitError(
        context,
        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,
        m.index
      )
    }
  }

  advanceBy(context, name.length)

  // Value
  let value:
    | {
        content: string
        isQuoted: boolean
        loc: SourceLocation
      }
    | undefined = undefined

  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context)
    advanceBy(context, 1)
    advanceSpaces(context)
    value = parseAttributeValue(context)
    if (!value) {
      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)
    }
  }
  const loc = getSelection(context, start)

  ... 
 
  return {
    type: NodeTypes.ATTRIBUTE,
    name,
    value: value &amp;&amp; {
      type: NodeTypes.TEXT,
      content: value.content,
      loc: value.loc
    },
    loc
  }
}
</code></pre></div><p>å¯¹äº parseAttribute ï¼Œä¸Šé¢æˆ‘ä»¬å¿½ç•¥äº†ä¸¤ä¸ªç‚¹ï¼Œç¬¬ä¸€ä¸ª parseAttributeValue ï¼Œç¬¬äºŒæ˜¯æŒ‡ä»¤å±æ€§ã€‚</p> <p>å…ˆçœ‹çœ‹ parseAttributeValueï¼Œé¦–å…ˆä¿å­˜å¼€å§‹ä½ç½®ï¼Œè¿™éƒ½æ˜¯ä¸ºäº†æœ€å AST çš„ locï¼Œç„¶åçœ‹çœ‹æˆ‘ä»¬çš„å±æ€§å€¼æ˜¯ä¸æ˜¯è¢« <code>&quot;</code> æˆ–è€… <code>'</code> åŒ…èµ·æ¥äº†ï¼Œå¦‚æœåŒ…èµ·æ¥äº†ï¼Œè§£æå‰å…ˆå¾€å‰æ¨è¿›ä¸€ä½ï¼ŒåŒæ—¶å¯»æ‰¾ç»“æŸç¬¦ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œç›´æ¥æ¶ˆè´¹å®Œæ•´ä¸ªå­—ç¬¦ä¸²ï¼Œ parseTextData æˆ‘ä»¬åœ¨ä¸Šé¢è®²è¿‡äº†ï¼Œå¦‚æœæ‰¾åˆ°äº†ï¼Œæ¶ˆè´¹ endIndex é•¿åº¦ä¸ªå­—ç¬¦ä¸²ï¼ŒåŒæ—¶æœ€åæ¶ˆè´¹ç»“æŸç¬¦ã€‚</p> <p>å¦‚æœæˆ‘ä»¬çš„å±æ€§å€¼æ²¡æœ‰è¢«å¼•å·åŒ…ä½ï¼Œé¦–å…ˆæ­£åˆ™åŒ¹é…ä¸€ä¸‹ï¼ŒåŸºæœ¬å°±æ˜¯ä¸å…è®¸ç©ºç™½ç¬¦å’Œæ ‡ç­¾'<code>&gt;</code>ï¼Œå¦‚æœåŒ¹é…å¤±è´¥ï¼Œç›´æ¥è¿”å›ï¼Œç„¶åè¿›è¡ŒäºŒæ¬¡æ­£åˆ™æ ¡éªŒï¼Œä¸å…è®¸ <code>/[&quot;'&lt;=</code>]<code>,éœ€è¦æ³¨æ„ ä¹Ÿä¸å¯»</code>&lt;<code>å’Œ</code>=<code>ï¼Œå¦åˆ™ä¸ŠæŠ¥</code>UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE<code>ã€‚è¿™äº›æ ¡éªŒéƒ½æ²¡é—®é¢˜ï¼Œå°±è¿”å› value çš„ AST è¡¨ç¤ºï¼Œæ³¨æ„</code>isQuoted` ä¹Ÿè¦è¿”å›å»ï¼Œåœ¨ parseAttribute ä¸­ä¿®å¤å†…å®¹ locã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseAttributeValue(
  context: ParserContext
):
  | {
      content: string
      isQuoted: boolean
      loc: SourceLocation
    }
  | undefined {
  const start = getCursor(context)
  let content: string

  const quote = context.source[0]
  const isQuoted = quote === `&quot;` || quote === `'`
  if (isQuoted) {
    // Quoted value.
    advanceBy(context, 1)

    const endIndex = context.source.indexOf(quote)
    if (endIndex === -1) {
      content = parseTextData(
        context,
        context.source.length,
        TextModes.ATTRIBUTE_VALUE
      )
    } else {
      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)
      advanceBy(context, 1)
    }
  } else {
    // Unquoted
    const match = /^[^\t\r\n\f &gt;]+/.exec(context.source)
    if (!match) {
      return undefined
    }
    const unexpectedChars = /[&quot;'&lt;=`]/g
    let m: RegExpExecArray | null
    while ((m = unexpectedChars.exec(match[0]))) {
      emitError(
        context,
        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,
        m.index
      )
    }
    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)
  }

  return { content, isQuoted, loc: getSelection(context, start) }
}
</code></pre></div><p>ç°åœ¨æˆ‘ä»¬å†æ¥çœ‹çœ‹ parseAttribute ä¸­å¯¹ æŒ‡ä»¤å±æ€§çš„å¤„ç†ã€‚å¦‚æœå‡ºäº inVPre ç¯å¢ƒï¼Œåˆ™æˆ‘ä»¬ä¸éœ€è¦å¯¹æŒ‡ä»¤è¿›è¡Œå¤„ç†ï¼Œä½†æ˜¯æœ‰å¯èƒ½æˆ‘ä»¬çˆ¶çº§ä¸æ˜¯ inVPreï¼Œä½†å½“å‰ tag æœ‰ v-pre æŒ‡ä»¤ï¼Œæˆ‘ä»¬å¯èƒ½ä¸€å¼€å§‹è¿›å»è¿™é‡Œå¤„ç†äº†ï¼Œåé¢è§£æå®Œæ¯•ä¹‹åï¼Œå‘ç°ä¸éœ€è¦äºŒæ¬¡å¤„ç†ï¼Œæ‰€ä»¥éœ€è¦é‡æ–°é‡æ–°è§£æå±æ€§ã€‚ä½†ä¸ºä»€ä¹ˆä¸åœ¨è¿™é‡Œåšä¸ªæ ¡éªŒå‘¢ï¼Ÿå¥‡æ€ªäº†</p> <p><code>/^(v-|:|@|#)/.test(name)</code> è¿™ä¸ªæ­£åˆ™æ˜¯ä¸ºäº†åˆæ­¥åˆ¤æ–­å±æ€§æ˜¯ä¸æ˜¯æŒ‡ä»¤ï¼Œåœ¨è¿›å» if åˆ¤æ–­ä¹‹åï¼Œä¼šç”¨æ­£åˆ™åšè¿›ä¸€æ­¥çš„åˆ¤æ–­ï¼Œ<code>/(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i</code> è¿™ä¸ªçœ‹èµ·æ¥å¾ˆå¤æ‚çš„æ­£åˆ™ï¼Œå°±æ˜¯ä¸ºäº†æå–å±æ€§åä¸­çš„æŒ‡ä»¤åã€æŒ‡ä»¤çš„å‚æ•°ä»¥åŠæ‰§è¡Œçš„ä¿®é¥°ç¬¦ã€‚</p> <p>å¯¹äºåˆ†ç»„2å‰é¢çš„ <code>(?::|^@|^#)</code>ï¼Œå±äºæŒ‡ä»¤çš„è¯­æ³•ç³–ï¼Œåˆ†åˆ«ä»£è¡¨ bindã€ click å’Œslotï¼Œè¿™ä¸ªæˆ‘ä»¬åœ¨è¿”å›æŒ‡ä»¤ AST çš„ name é‚£é‡Œä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬éœ€è¦è§£å†³çš„åˆ†ç»„2çš„å†…å®¹è¿›è¡Œæ ¡éªŒï¼Œåˆ†ç»„2å±äºæŒ‡ä»¤çš„å‚æ•°ï¼Œå¯ä»¥æ˜¯åŠ¨æ€çš„ï¼Œåƒ <code>v-on:[event]</code>, event å°±æ˜¯åŠ¨æ€å‚æ•°ï¼Œä½†æ˜¯ <code>v-on:[event test]</code> ä¼šä¸ŠæŠ¥ <code>X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END</code> é”™è¯¯çš„ï¼Œå› ä¸ºå‰é¢æˆ‘ä»¬åŒ¹é…å±æ€§åæ­£åˆ™çš„æ—¶å€™ï¼Œä¸åŒ…æ‹¬ç©ºæ ¼ï¼Œæ‰€ä»¥åŠ¨æ€å‚æ•°æ‰¾ä¸åˆ°ç»“æŸç¬¦ <code>]</code>ã€‚å‚æ•°ä¹Ÿä¼šè¿”å›ä¸€ä¸ª ASTï¼Œç±»å‹æ˜¯ SIMPLE_EXPRESSIONï¼Œå…¶ä¸­ isStatic æ˜¯ç”± å‚æ•°æ˜¯ä¸æ˜¯åŠ¨æ€å†³å®šçš„ã€‚</p> <p>æ¥ç€æŒ‡ä»¤è¿˜ä¼šå¯¹å±æ€§å†…å®¹ä½ç½®è¿›è¡Œè£å‰ªï¼Œå¦‚æœæ˜¯ isQuoted ï¼Œä¹Ÿä¼šæŠŠèƒ½å±æ€§å†…å®¹ä½ç½®ä¸­çš„å†…å®¹çš„å¼•å·å»æ‰ï¼ŒåŒæ—¶ä¿®å¤é‡Œé¢çš„å¼€å§‹ã€ç»“æŸä½ç½®ã€‚</p> <p>æœ€åæå‰è¿”å›æŒ‡ä»¤çš„ ASTï¼Œç±»å‹æ˜¯ NodeTypes.DIRECTIVEï¼Œ å…¶ä¸­ name ä¸Šé¢è¯´è¿‡ï¼Œexp æ˜¯è®²å±æ€§å†…å®¹è½¬åŒ–æˆ AST ç±»å‹ä¸º SIMPLE_EXPRESSION çš„èŠ‚ç‚¹ï¼Œå…¶ä¸­è¿™ä¸ªèŠ‚ç‚¹ isConstant ä¼šåœ¨ transformExpression èŠ‚ç‚¹ç¡®å®šçš„ï¼Œç°åœ¨éœ€è¦åšçš„å°±æ˜¯æŠŠè¿™ç‚¹è®°åœ¨æœ¬å­ä¸Šã€‚arg æ˜¯æŒ‡ä»¤å‚æ•°ï¼Œmodifiers æ˜¯æŒ‡ä»¤çš„ä¿®é¥°ç¬¦ï¼Œå±äºæ­£åˆ™ä¸­çš„åˆ†ç»„3é‡Œé¢çš„å†…å®¹ã€</p> <div class="language- extra-class"><pre class="language-text"><code>if (!context.inVPre &amp;&amp; /^(v-|:|@|#)/.test(name)) {
    const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(
      name
    )!
    
    let arg: ExpressionNode | undefined
    
    if (match[2]) {
      const startOffset = name.indexOf(match[2])
      const loc = getSelection(
        context,
        getNewPosition(context, start, startOffset),
        getNewPosition(context, start, startOffset + match[2].length)
      )
      let content = match[2]
      let isStatic = true
    
      if (content.startsWith('[')) {
        isStatic = false
    
        if (!content.endsWith(']')) {
          emitError(
            context,
            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END
          )
        }
    
        content = content.substr(1, content.length - 2)
      }
    
      arg = {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content,
        isStatic,
        isConstant: isStatic,
        loc
      }
    }
    
    if (value &amp;&amp; value.isQuoted) {
      const valueLoc = value.loc
      valueLoc.start.offset++
      valueLoc.start.column++
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
      valueLoc.source = valueLoc.source.slice(1, -1)
    }
    
    return {
      type: NodeTypes.DIRECTIVE,
      name:
        match[1] ||
        (startsWith(name, ':')
          ? 'bind'
          : startsWith(name, '@')
            ? 'on'
            : 'slot'),
      exp: value &amp;&amp; {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // true by `transformExpression` to make it eligible for hoisting.
        isConstant: false,
        loc: value.loc
      },
      arg,
      modifiers: match[3] ? match[3].substr(1).split('.') : [],
      loc
    }
}
</code></pre></div><p>ç»ˆäºæŠŠ parseAttribute è®²å®Œäº†ï¼ŒparseAttribute å›åˆ° parseAttributesï¼ŒparseAttributes å›åˆ° parseTag, parseTag å›åˆ°  parseElementï¼Œè¿™ä¸ªè°ƒç”¨æ ˆæœ‰ç‚¹é•¿ï¼Œå¸Œæœ›ä½ ä»¬è¿˜æ²¡æ™•ã€‚</p> <p>è¿˜è®°å¾—æˆ‘ä»¬åœ¨è¿›å» parseTag è¿™ä¸ªæ—‹æ¶¡ä¹‹å‰ï¼ŒparseElement è®²åˆ°é‚£é‡Œäº†å—ï¼Ÿæˆ‘ä»¬è®²åˆ°äº† <code>const element = parseTag(context, TagType.Start, parent)</code> è¿™é‡Œï¼ŒOKï¼Œè¿™é‡Œæˆ‘ä»¬ç»ˆäºæ‹¿åˆ°äº†æˆ‘ä»¬è§£æçš„å…ƒç´ äº†ã€‚</p> <p>isPreBoundary ä¸º trueï¼Œè¯´æ˜æˆ‘ä»¬è¿™ä¸ªå…ƒç´ å°±æ˜¯ pre ï¼Œå› ä¸º wasInPre ä¸º falseï¼ŒåŒç† isVPreBoundary æ˜¯ v-pre çš„æ ‡è¯†ã€‚</p> <p>å¯¹äºå…ƒç´ è‡ªå·±å…³é—­çš„ï¼Œæˆ–è€…æ˜¯å¹³å°çš„ isVoidTag ï¼Œç›´æ¥è¿”å› elementï¼Œå› ä¸ºä¸éœ€è¦ä¸‹é¢çš„è§£æå­å…ƒç´ å’Œç»“æŸæ ‡ç­¾ã€‚</p> <p>å¯¹äºè§£æå­å…ƒç´ å‰ï¼Œé¦–å…ˆæŠŠå½“å‰å…ƒç´ æ¨å…¥ ancestors ä¸­ï¼Œancestors å½±å“åˆ°äº†æˆ‘ä»¬æ€ä¹ˆå»ç»“æŸ parseChildrenã€namespace çš„åˆ¤æ–­ç­‰ç­‰ï¼ŒåŒæ—¶è¿™ä¹Ÿæ˜¯è§£æä¸­å”¯ä¸€å…¥æ ˆçš„åœ°æ–¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºå…¶ä»–è§£ææ¥è¯´ï¼Œå¦‚paeCommentã€paserBogusComment ç­‰ç­‰ï¼Œéƒ½æ˜¯æ²¡æœ‰å­å…ƒç´ çš„ï¼Œæˆ‘ä»¬ä» parseTag çš„ AST çœ‹åˆ° children ä¹Ÿå¯ä»¥å¤§æ¦‚çŒœåˆ°äº†ã€‚æ¥ç€æ‹¿ modeï¼ŒgetTextMode æœ€ä¸Šé¢è®²è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œåªæœ‰å½“å‰å…ƒç´ å‘½åç©ºé—´æ˜¯ DOMNamespaces.HTML æ—¶ï¼ŒgetTextMode æ‰ä¼šè¿”å›å…¶ä»–çš„TextModesï¼Œå¦åˆ™ä¸€å¾‹éƒ½æ˜¯ TextModes.DATAï¼Œè€Œæˆ‘ä»¬ä¹ŸçŸ¥é“ï¼ŒparseChildren åªå¯¹ <code>mode === TextModes.DATA || mode === TextModes.RCDATA</code> è¿™ä¸¤ä¸ªæ¨¡å¼æœ‰ç»†è‡´çš„è§£æï¼Œä¸ç„¶éƒ½æ˜¯èµ°ç²—æš´çš„ parseTextã€‚ parseChildren è§£æå®Œæ¯•ä¹‹åï¼Œè¿”å›çš„ nodes èŠ‚ç‚¹ï¼Œå¡å…¥  element çš„ childrenï¼ŒåŒæ—¶æŠŠ element ä» ancestors ä¸­å¼¹å‡ºã€‚ç„¶åæˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬çš„ element æœ‰æ²¡æœ‰å…³é—­æ ‡ç­¾ï¼Œå¦‚æœæœ‰ï¼Œè°ƒç”¨ parseTag å»è§£æï¼Œåˆ«å¿˜è®°å‰é¢è¿™ä¸ªå…³é—­æ ‡ç­¾ä¸èƒ½æœ‰å±æ€§ï¼Œè¿™ä¸ªè¿”å›çš„ AST ä¸éœ€è¦ä¿å­˜ï¼Œæˆ‘ä»¬åªæ˜¯ä¸ºäº†æ¨è¿› contextã€‚å¦‚æœæ²¡æœ‰å…³é—­æ ‡ç­¾ï¼Œä¸ŠæŠ¥ <code>X_MISSING_END_TAG</code>, è€Œå¦‚æœç”šè‡³è¿ source ä¹Ÿæ²¡äº†ï¼Œelement çš„ tag æ˜¯ scriptï¼Œä¸”å½“å‰ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ³¨é‡Šï¼Œä¸ŠæŠ¥ <code>EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT</code>,å¾ˆæ‡µåœˆæ˜¯ä¸ï¼Œæ¥ï¼Œç»™ä½ çœ‹æµ‹è¯•ç”¨ä¾‹,
<code>&lt;script&gt;&lt;!--console.log('hello')</code>, get ï¼Ÿ</p> <p>parseElement ä¿®å¤ç»“æŸæ ‡ç­¾çš„ä½ç½®ï¼ŒåŒæ—¶é‡ç½® context ä¸­çš„ inPre å’Œ inVPre, å¯ä»¥çœ‹åˆ° parseElement ç›¸æ¯”äº parseTag çš„ASTï¼Œå°±æ˜¯æ·»åŠ äº†å­å…ƒç´ çš„ ASTï¼ŒåŒæ—¶ä¿®å¤ locï¼Œè¿˜æœ‰æ¶ˆè´¹ç»“æŸæ ‡ç­¾ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>function parseElement(
  context: ParserContext,
  ancestors: ElementNode[]
): ElementNode | undefined {
  __TEST__ &amp;&amp; assert(/^&lt;[a-z]/i.test(context.source))

  // Start tag.
  const wasInPre = context.inPre
  const wasInVPre = context.inVPre
  const parent = last(ancestors)
  const element = parseTag(context, TagType.Start, parent)
  const isPreBoundary = context.inPre &amp;&amp; !wasInPre
  const isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre

  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    return element
  }

  // Children.
  ancestors.push(element)
  const mode = context.options.getTextMode(element, parent)
  const children = parseChildren(context, mode, ancestors)
  ancestors.pop()

  element.children = children

  // End tag.
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent)
  } else {
    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)
    if (context.source.length === 0 &amp;&amp; element.tag.toLowerCase() === 'script') {
      const first = children[0]
      if (first &amp;&amp; startsWith(first.loc.source, '&lt;!--')) {
        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)
      }
    }
  }

  element.loc = getSelection(context, element.loc.start)

  if (isPreBoundary) {
    context.inPre = false
  }
  if (isVPreBoundary) {
    context.inVPre = false
  }
  return element
}
</code></pre></div><p>parseElment çš„ä¸Šä¸€çº§è°ƒç”¨æ ˆæ˜¯ parseChildrenï¼Œè¿˜è®°å¾—æˆ‘ä»¬å¤§æ˜æ¹–ç•”çš„ while å¾ªç¯å—ï¼ŸparseElement æˆ‘ä»¬åˆ†æå®Œäº†ï¼Œ<code>s[1] === '?'</code> å°±æ˜¯ <code>&lt;?</code>ï¼Œæˆ‘ä»¬ä¹Ÿè®²è¿‡äº†ã€‚è¿™äº›æ¡ä»¶éƒ½ä¸æ»¡è¶³ï¼Œä¸ŠæŠ¥ <code>INVALID_FIRST_CHARACTER_OF_TAG_NAME</code> é”™è¯¯ï¼Œå°±æ˜¯ <code>&lt;</code> åé¢ä¸çŸ¥é“è·Ÿç€æ˜¯ä»€ä¹ˆå­—ç¬¦ä¸²ã€‚åæ­£æœ€åæœ‰ parseText å…œåº•ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>else if (/[a-z]/i.test(s[1])) {
  node = parseElement(context, ancestors)
} else if (s[1] === '?') {
  emitError(
    context,
    ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,
    1
  )
  node = parseBogusComment(context)
} else {
  emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)
}
</code></pre></div><p>çœ‹çœ‹ï¼ŒparseText å…œåº•ï¼Œæ¥ä¸‹æ¥å°±æ˜¯è°ƒç”¨ pushNode æŠŠè¿”å›çš„èŠ‚ç‚¹å¡å…¥ nodesï¼Œä¸ºä»€ä¹ˆ node ä¼šæ˜¯æ•°ç»„å‘¢ï¼Ÿ parseCDATA é‡Œé¢è°ƒç”¨ parseChildren ï¼Œè€Œ parseCDATA çš„è§£æéƒ½æ˜¯åŒçº§çš„ï¼Œæ‰€ä»¥ä½ æ‡‚çš„ã€‚pushNode çš„ç›®çš„ï¼Œå°±æ˜¯ä¸ºäº†åˆå¹¶ç›¸é‚» NodeTypes.TEXT èŠ‚ç‚¹ï¼Œå†æ‹¿  parseCDATA ä¸¾ä¾‹ï¼Œåœ¨è§£æè¿‡ç¨‹ä¸­ï¼ŒparseText ä¼šæ ¹æ® endTokens åˆ‡å‰²èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¼šå‡ºç°å¤šä¸ª NodeTypes.TEXT ä¸åœ¨åŒä¸ª ASTï¼ŒåŒæ ·è¿˜æœ‰æ³¨é‡Šä¸­çš„ä¾‹å­ï¼Œ<code>a &lt; b</code>ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>if (!node) {
  node = parseText(context, mode)
}

if (isArray(node)) {
  for (let i = 0; i &lt; node.length; i++) {
    pushNode(nodes, node[i])
  }
} else {
  pushNode(nodes, node)
}
function pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void {
  // ignore comments in production
  /* istanbul ignore next */
  if (!__DEV__ &amp;&amp; node.type === NodeTypes.COMMENT) {
    return
  }

  if (node.type === NodeTypes.TEXT) {
    const prev = last(nodes)
    // Merge if both this and the previous node are text and those are
    // consecutive. This happens for cases like &quot;a &lt; b&quot;.
    if (
      prev &amp;&amp;
      prev.type === NodeTypes.TEXT &amp;&amp;
      prev.loc.end.offset === node.loc.start.offset
    ) {
      prev.content += node.content
      prev.loc.end = node.loc.end
      prev.loc.source += node.loc.source
      return
    }
  }

  nodes.push(node)
}
</code></pre></div><p>parseChildren æ”¶å°¾éƒ¨åˆ†ï¼Œæ˜¯è¦è¦å¯¹èŠ‚ç‚¹ä¸­çš„ NodeTypes.TEXT ä¸­ç©ºç™½èŠ‚ç‚¹è¿›è¡Œå¤„ç†ã€‚å¯¹äº TextModes.RAWTEXT æ¨¡å¼å°±ä¸è¿›è¡Œå¤„ç†äº†ã€‚</p> <p>å¦‚æœæ˜¯å…¶ä»–æ¨¡å¼ï¼Œcontext.inPre ä¸º falseï¼Œå¾ªç¯æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚å¦‚æœ<code>!/[^\t\r\n\f ]/.test(node.content)</code> ä¸ºçœŸï¼Œ è¡¨ç¤ºè¿™ä¸ªèŠ‚ç‚¹æ˜¯ç©ºç™½èŠ‚ç‚¹ï¼Œå¯¹äºç©ºç™½èŠ‚ç‚¹ï¼Œæ³¨é‡Šä¹Ÿå†™çš„å¾ˆæ¸…æ¥šäº†ï¼Œå¯¹äºç¬¬ä¸€ä¸ªæˆ–è€…æœ€åä¸€ä¸ªç©ºç™½èŠ‚ç‚¹ï¼Œå¯ä»¥å¿½ç•¥ï¼ŒåŒæ—¶å¦‚æœç§»é™¤æ³¨é‡Šå‰åçš„ç©ºç™½èŠ‚ç‚¹ï¼Œè€Œå¯¹äºå¤¹åœ¨ä¸¤ä¸ªå…ƒç´ ä¸­é—´çš„ç©ºç™½èŠ‚ç‚¹ï¼Œå¦‚æœè¿™ä¸ªç©ºç™½èŠ‚ç‚¹æ˜¯å«æœ‰æ¢è¡Œç¬¦ï¼Œæ‰æ‰è¿›è¡Œç§»é™¤ï¼Œå¦‚æœè¦ç§»é™¤èŠ‚ç‚¹ï¼Œå°±å°† <code>removedWhitespace</code> è®¾ä¸º true,è¿™æ ·åœ¨æœ€åè¿”å›çš„æ—¶å€™ï¼Œç”¨ filter(Boolean) è¿‡æ»¤ç½®ç©ºçš„ç©ºç™½èŠ‚ç‚¹ï¼Œ<code>nodes[i] = null as any</code> å°±æ˜¯è¿™æ ·ç½®ç©ºã€‚å¦‚æœç©ºç™½èŠ‚ç‚¹ä¸æ»¡è¶³ä¸Šé¢çš„æ¡ä»¶ï¼ŒæŠŠç©ºç™½èŠ‚ç‚¹çš„å†…å®¹ç¼©å‡æˆä¸€ä¸ªç©ºç™½ã€‚æœ€åè€Œå¯¹äºä¸æ˜¯ç©ºç™½èŠ‚ç‚¹çš„ NodeTypes.TEXT èŠ‚ç‚¹ï¼Œç§»é™¤å†…å®¹ä¸­çš„ç©ºç™½ã€‚</p> <p>å¦‚æœå¯¹äº context.inPre ä¸º true ï¼Œè€Œçˆ¶çº§å°±æ˜¯ pre å…ƒç´ çš„ï¼Œç§»é™¤ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æ¢è¡Œç¬¦ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åªå…³å¿ƒ pre ä¸‹é¢ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å¼€å¤´ä¸èƒ½æ˜¯æ¢è¡Œç¬¦ï¼Œå­™å­èŠ‚ç‚¹ä¸åœ¨åœ¨ä¹ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>// Whitespace management for more efficient output
  // (same as v2 whitespace: 'condense')
  let removedWhitespace = false
  if (mode !== TextModes.RAWTEXT) {
    if (!context.inPre) {
      for (let i = 0; i &lt; nodes.length; i++) {
        const node = nodes[i]
        if (node.type === NodeTypes.TEXT) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1]
            const next = nodes[i + 1]
            // If:
            // - the whitespace is the first or last node, or:
            // - the whitespace is adjacent to a comment, or:
            // - the whitespace is between two elements AND contains newline
            // Then the whitespace is ignored.
            if (
              !prev ||
              !next ||
              prev.type === NodeTypes.COMMENT ||
              next.type === NodeTypes.COMMENT ||
              (prev.type === NodeTypes.ELEMENT &amp;&amp;
                next.type === NodeTypes.ELEMENT &amp;&amp;
                /[\r\n]/.test(node.content))
            ) {
              removedWhitespace = true
              nodes[i] = null as any
            } else {
              // Otherwise, condensed consecutive whitespace inside the text down to
              // a single space
              node.content = ' '
            }
          } else {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ')
          }
        }
      }
    } else if (parent &amp;&amp; context.options.isPreTag(parent.tag)) {
      // remove leading newline per html spec
      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
      const first = nodes[0]
      if (first &amp;&amp; first.type === NodeTypes.TEXT) {
        first.content = first.content.replace(/^\r?\n/, '')
      }
    }
  }

  return removedWhitespace ? nodes.filter(Boolean) : nodes

</code></pre></div><p>è¡¥å……è¯´ä¸€ç‚¹ï¼Œçœ‹çœ‹ä¸‹é¢ä¸¤ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œä¸ºä»€ä¹ˆç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹è¦ç§»é™¤ç©ºç™½èŠ‚ç‚¹ï¼Œç¬¬äºŒä¸ªä¸ç”¨å‘¢ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªç”¨ä¾‹çš„ç©ºç™½èŠ‚ç‚¹æ˜¯è·Ÿ span åŒçº§çš„ï¼Œç§»é™¤ç¬¬ä¸€ä¸ªå’Œæœ€åç©ºç™½èŠ‚ç‚¹ï¼Œç¬¬äºŒä¸ªç”¨ä¾‹ä¸­çš„ç©ºç™½èŠ‚ç‚¹ï¼Œå±äºåŒçº§å…ƒç´ é—´çš„ç©ºç™½èŠ‚ç‚¹ä¸”æ²¡æœ‰æ¢è¡Œç¬¦ï¼Œæ‰€ä»¥ä¸éœ€è¦ç§»é™¤ã€‚</p> <div class="language- extra-class"><pre class="language-text"><code>it('should remove whitespaces at start/end inside an element', () =&gt; {
  const ast = baseParse(`&lt;div&gt;   &lt;span/&gt;    &lt;/div&gt;`)
  expect((ast.children[0] as ElementNode).children.length).toBe(1)
})
it('should NOT remove whitespaces w/o newline between elements', () =&gt; {
  const ast = baseParse(`&lt;div/&gt; &lt;div/&gt; &lt;div/&gt;`)
  expect(ast.children.length).toBe(5)
  expect(ast.children.map(c =&gt; c.type)).toMatchObject([
    NodeTypes.ELEMENT,
    NodeTypes.TEXT,
    NodeTypes.ELEMENT,
    NodeTypes.TEXT,
    NodeTypes.ELEMENT
  ])
})
</code></pre></div><p>é•¿å‘¼ä¸€å£æ°”ï¼Œparse æ¨¡å—ç»ˆäºè®²å®Œäº†ã€‚åªè¦æ˜¯çŸ¥é“é‡Œé¢ parseChildren æ˜¯ä¸ªåµŒå¥—è°ƒç”¨çš„è¿‡ç¨‹ï¼Œé‡Œé¢è¿˜è¦è¿›è¡Œä¸€å®šçš„å®¹é”™ï¼ŒåŒæ—¶ ns å’Œ mode ä¼šå½±å“è§£æï¼Œæ‰“å®Œæ”¶å·¥</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      â†
      <a href="/slamdunk-the-vue3/main/vue/compiler/compiler.html" class="prev">
        compiler
      </a></span> <span class="next"><a href="/slamdunk-the-vue3/main/vue/compiler/transform.html">
        transform(å‡†å¤‡å¼€å§‹æ–½å·¥ğŸš§)
      </a>
      â†’
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/slamdunk-the-vue3/assets/js/app.5cce7937.js" defer></script><script src="/slamdunk-the-vue3/assets/js/2.53f3bd5a.js" defer></script><script src="/slamdunk-the-vue3/assets/js/12.62ea020d.js" defer></script>
  </body>
</html>
